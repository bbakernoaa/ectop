{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"ectop","text":"<p><code>ectop</code> is a powerful Textual-based Terminal User Interface (TUI) for monitoring and controlling ecFlow servers.</p>","path":["ectop"],"tags":[]},{"location":"#features","level":2,"title":"Features","text":"<ul> <li>Real-time Monitoring: View the status of your ecFlow suites, families, and tasks in a hierarchical tree view. The UI updates periodically to reflect the latest server state.</li> <li>Node Management: Perform common ecFlow operations directly from the TUI:<ul> <li>Suspend/Resume: Pause or continue execution of nodes.</li> <li>Kill: Terminate running tasks.</li> <li>Force Complete: Manually set a node to the complete state.</li> <li>Requeue: Reset a node for execution.</li> </ul> </li> <li>File Inspection: Quickly view logs, scripts, and generated job files:<ul> <li>Log Output: Live view of task logs with optional auto-refresh.</li> <li>Scripts: View the original ecFlow script.</li> <li>Jobs: Inspect the generated job file.</li> </ul> </li> <li>Search: Interactive live search to find nodes in large suites, optimized with lazy loading.</li> <li>Command Palette: Searchable command interface for quick access to all application actions.</li> <li>Why?: A dedicated \"Why\" inspector to understand why a node is in its current state (e.g., waiting for triggers or limits).</li> <li>Variable Management: View and modify node variables (Edit and Add) on the fly.</li> <li>Interactive Script Editing: Edit scripts using your preferred local editor (via <code>$EDITOR</code>) and update them on the ecFlow server instantly.</li> </ul>","path":["ectop"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"","path":["ectop"],"tags":[]},{"location":"#using-conda-recommended","level":3,"title":"Using Conda (Recommended)","text":"<p>Since <code>ecflow</code> is primarily distributed via Conda, this is the easiest way to get started:</p> <pre><code>conda env create -f environment.yml\nconda activate ectop\n</code></pre>","path":["ectop"],"tags":[]},{"location":"#using-pip","level":3,"title":"Using Pip","text":"<p>If you already have <code>ecflow</code> installed on your system:</p> <pre><code>pip install .\n</code></pre>","path":["ectop"],"tags":[]},{"location":"#usage","level":2,"title":"Usage","text":"<p>Start <code>ectop</code> by running:</p> <pre><code>ectop\n</code></pre>","path":["ectop"],"tags":[]},{"location":"#configuration-environment-variables","level":3,"title":"Configuration &amp; Environment Variables","text":"<p><code>ectop</code> can be configured via command-line arguments or environment variables.</p> <ul> <li>Server Host:<ul> <li>CLI: <code>ectop --host &lt;hostname&gt;</code></li> <li>Environment: <code>ECF_HOST</code> (defaults to <code>localhost</code>)</li> </ul> </li> <li>Server Port:<ul> <li>CLI: <code>ectop --port &lt;port&gt;</code></li> <li>Environment: <code>ECF_PORT</code> (defaults to <code>3141</code>)</li> </ul> </li> <li>Refresh Interval:<ul> <li>CLI: <code>ectop --refresh &lt;seconds&gt;</code></li> <li>Environment: <code>ECTOP_REFRESH</code> (defaults to <code>2.0</code>)</li> </ul> </li> <li>Editor:<ul> <li><code>ectop</code> uses the <code>EDITOR</code> environment variable for script editing. If not set, it defaults to <code>vi</code>.</li> </ul> </li> </ul>","path":["ectop"],"tags":[]},{"location":"#key-bindings","level":3,"title":"Key Bindings","text":"Key Action <code>q</code> Quit the application <code>p</code> Open Command Palette <code>r</code> Refresh the entire suite tree from the server <code>l</code> Load Logs, Script, and Job files for the selected node <code>s</code> Suspend the selected node <code>u</code> Resume the selected node <code>k</code> Kill the selected task <code>f</code> Force Complete the selected node <code>/</code> Open Search box (Live search) <code>w</code> Open Why? inspector for the selected node <code>e</code> Edit the node script in your local editor and update server <code>t</code> Toggle Live log updates for the current node <code>v</code> View/Edit Variables for the selected node","path":["ectop"],"tags":[]},{"location":"#documentation","level":2,"title":"Documentation","text":"<ul> <li>Tutorial</li> <li>Architecture</li> <li>Reference</li> <li>Contributing</li> </ul>","path":["ectop"],"tags":[]},{"location":"architecture/","level":1,"title":"Architecture","text":"<p><code>ectop</code> is built using the Textual framework, providing a modern and responsive TUI experience.</p>","path":["Architecture"],"tags":[]},{"location":"architecture/#design-goals","level":2,"title":"Design Goals","text":"<ol> <li>Responsiveness: The UI should never freeze, even when performing long-running network operations or fetching large files.</li> <li>Simplicity: Provide a clean wrapper around the <code>ecflow</code> Python API.</li> <li>Extensibility: Modular widget design for easy expansion of features.</li> </ol>","path":["Architecture"],"tags":[]},{"location":"architecture/#core-components","level":2,"title":"Core Components","text":"","path":["Architecture"],"tags":[]},{"location":"architecture/#app-ectopappectop","level":3,"title":"App (<code>ectop.app.Ectop</code>)","text":"<p>The main application class that coordinates the UI, handles global key bindings, and manages the lifecycle of the application. It uses Textual's <code>Screen</code> and <code>Worker</code> systems to handle concurrency.</p>","path":["Architecture"],"tags":[]},{"location":"architecture/#client-ectopclientecflowclient","level":3,"title":"Client (<code>ectop.client.EcflowClient</code>)","text":"<p>A thin wrapper around <code>ecflow.Client</code>. It provides: - Simplified API for common operations. - Centralized error handling and conversion of <code>RuntimeError</code> into more informative exceptions. - Mapping of node states to visual icons.</p>","path":["Architecture"],"tags":[]},{"location":"architecture/#widgets-ectopwidgets","level":3,"title":"Widgets (<code>ectop.widgets</code>)","text":"<p>The UI is decomposed into several modular widgets: - SuiteTree: A customized <code>Tree</code> widget that displays the hierarchical structure of ecFlow suites. It uses lazy loading to only fetch and render nodes as they are expanded, ensuring high performance for large trees. - StatusBar: Displays real-time server connection status and the timestamp of the last successful synchronization. - MainContent: A <code>TabbedContent</code> widget that hosts the Log, Script, and Job views. - SearchBox: A specialized input for live-filtering the suite tree. - Modals: Lightweight screens for confirmation (<code>ConfirmModal</code>), variable editing (<code>VariableTweaker</code>), and \"Why\" inspection (<code>WhyInspector</code>).</p>","path":["Architecture"],"tags":[]},{"location":"architecture/#concurrency-and-workers","level":2,"title":"Concurrency and Workers","text":"<p>To maintain a smooth UI, all blocking calls to the ecFlow server (which involve network I/O) are offloaded to Textual Workers using the <code>@work</code> decorator.</p> <ul> <li>Thread-safe Updates: Workers that need to update the UI use <code>self.call_from_thread()</code> or Textual's message-passing system.</li> <li>Exclusive Workers: Operations like \"Refresh\" use <code>exclusive=True</code> to prevent multiple simultaneous sync operations.</li> </ul>","path":["Architecture"],"tags":[]},{"location":"architecture/#event-loop","level":2,"title":"Event Loop","text":"<p><code>ectop</code> uses a periodic interval (set in <code>on_mount</code>) to perform \"live\" updates, such as tailing log files when a node is active and the \"Live\" toggle is enabled.</p>","path":["Architecture"],"tags":[]},{"location":"contributing/","level":1,"title":"Contributing to ectop","text":"<p>Thank you for your interest in improving <code>ectop</code>!</p>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#development-environment","level":2,"title":"Development Environment","text":"<p>We recommend using Conda or Mamba to manage the development environment, as it simplifies the installation of the <code>ecflow</code> dependency.</p> <pre><code># Clone the repository\ngit clone https://github.com/bbakernoaa/ectop.git\ncd ectop\n\n# Create the environment\nconda env create -f environment.yml\nconda activate ectop\n\n# Install the package in editable mode with dev dependencies\npip install -e .[dev]\n</code></pre>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#coding-standards","level":2,"title":"Coding Standards","text":"<ul> <li>Python Version: Required 3.11+.</li> <li>Type Hints: All function signatures must include type hints.</li> <li>Documentation: We use NumPy-style docstrings.</li> <li>Formatting: We use <code>ruff</code> for linting and formatting.</li> </ul>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#pre-commit-hooks","level":3,"title":"Pre-commit Hooks","text":"<p>We use <code>pre-commit</code> to ensure code quality. Install the hooks with:</p> <pre><code>pre-commit install\n</code></pre>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#running-tests","level":2,"title":"Running Tests","text":"<p><code>ectop</code> uses <code>pytest</code> and <code>pytest-asyncio</code> for testing.</p> <pre><code># Run all tests\npytest\n\n# Run tests with coverage\npytest --cov=src\n</code></pre> <p>Note: Some tests mock the <code>ecflow</code> client to avoid requiring a running server.</p>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#building-documentation","level":2,"title":"Building Documentation","text":"<p>Documentation is built with <code>mkdocs</code> and the <code>mkdocs-material</code> theme.</p> <pre><code># Install doc dependencies\npip install -e .[docs]\n\n# Serve the documentation locally\nmkdocs serve\n</code></pre>","path":["Contributing to ectop"],"tags":[]},{"location":"contributing/#pull-request-process","level":2,"title":"Pull Request Process","text":"<ol> <li>Create a new branch for your feature or bugfix.</li> <li>Ensure all tests pass and linting is clean.</li> <li>Include unit tests for any new functionality.</li> <li>Update the documentation if you change the API or usage.</li> <li>Submit a Pull Request to the <code>main</code> branch.</li> </ol>","path":["Contributing to ectop"],"tags":[]},{"location":"reference/","level":1,"title":"Reference","text":"<p>This section contains the automatically generated API documentation for <code>ectop</code>.</p>","path":["Reference"],"tags":[]},{"location":"reference/#core","level":2,"title":"Core","text":"<p>Main application class for ectop.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>ecFlow Client Wrapper for ectop.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>CLI entry point for ectop.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Constants for the ectop application.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop","level":2,"title":"<code>Ectop</code>","text":"<p>               Bases: <code>App</code></p> <p>A Textual-based TUI for monitoring and controlling ecFlow.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/app.py</code> <pre><code>class Ectop(App):\n    \"\"\"\n    A Textual-based TUI for monitoring and controlling ecFlow.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    CSS = f\"\"\"\n    Screen {{\n        background: {COLOR_BG};\n    }}\n\n    StatusBar {{\n        dock: bottom;\n        height: 1;\n        background: {COLOR_STATUS_BAR_BG};\n        color: {COLOR_TEXT};\n    }}\n\n    /* Left Sidebar (Tree) */\n    #sidebar {{\n        width: 30%;\n        height: 100%;\n        border-right: solid {COLOR_BORDER};\n        background: {COLOR_SIDEBAR_BG};\n    }}\n\n    Tree {{\n        background: {COLOR_SIDEBAR_BG};\n        color: {COLOR_TEXT};\n        padding: 1;\n    }}\n\n    /* Right Content (Tabs) */\n    #main_content {{\n        width: 70%;\n        height: 100%;\n    }}\n\n    TabbedContent {{\n        height: 100%;\n    }}\n\n    /* Content Areas */\n    RichLog {{\n        background: {COLOR_CONTENT_BG};\n        color: {COLOR_TEXT_HIGHLIGHT};\n        border: none;\n    }}\n\n    .code_view {{\n        background: {COLOR_CONTENT_BG};\n        padding: 1;\n        width: 100%;\n        height: auto;\n    }}\n\n    #search_box {{\n        dock: top;\n        display: none;\n        background: {COLOR_CONTENT_BG};\n        color: {COLOR_TEXT_HIGHLIGHT};\n        border: tall {COLOR_BORDER};\n    }}\n\n    #search_box.visible {{\n        display: block;\n    }}\n\n    #why_container {{\n        padding: 1 2;\n        background: {COLOR_BG};\n        border: thick {COLOR_BORDER};\n        width: 60%;\n        height: 60%;\n    }}\n\n    #why_title {{\n        text-align: center;\n        background: {COLOR_HEADER_BG};\n        color: white;\n        margin-bottom: 1;\n    }}\n\n    #confirm_container {{\n        padding: 1 2;\n        background: {COLOR_BG};\n        border: thick {COLOR_BORDER};\n        width: 40%;\n        height: 20%;\n    }}\n\n    #confirm_message {{\n        text-align: center;\n        margin-bottom: 1;\n    }}\n\n    #confirm_actions {{\n        align: center middle;\n    }}\n\n    #confirm_actions Button {{\n        margin: 0 1;\n    }}\n\n    #var_container {{\n        padding: 1 2;\n        background: {COLOR_BG};\n        border: thick {COLOR_BORDER};\n        width: 80%;\n        height: 80%;\n    }}\n\n    #var_title {{\n        text-align: center;\n        background: {COLOR_HEADER_BG};\n        color: white;\n        margin-bottom: 1;\n    }}\n\n    #var_input.hidden {{\n        display: none;\n    }}\n    \"\"\"\n\n    COMMANDS = App.COMMANDS | {EctopCommands}\n\n    BINDINGS = [\n        Binding(\"q\", \"quit\", \"Quit\"),\n        Binding(\"p\", \"command_palette\", \"Command Palette\"),\n        Binding(\"r\", \"refresh\", \"Refresh Tree\"),\n        Binding(\"l\", \"load_node\", \"Load Logs/Script\"),\n        Binding(\"s\", \"suspend\", \"Suspend\"),\n        Binding(\"u\", \"resume\", \"Resume\"),\n        Binding(\"k\", \"kill\", \"Kill\"),\n        Binding(\"f\", \"force\", \"Force Complete\"),\n        Binding(\"F\", \"cycle_filter\", \"Cycle Filter\"),\n        Binding(\"R\", \"requeue\", \"Requeue\"),\n        Binding(\"c\", \"copy_path\", \"Copy Path\"),\n        Binding(\"S\", \"restart_server\", \"Start Server\"),\n        Binding(\"H\", \"halt_server\", \"Halt Server\"),\n        Binding(\"/\", \"search\", \"Search\"),\n        Binding(\"w\", \"why\", \"Why?\"),\n        Binding(\"e\", \"edit_script\", \"Edit &amp; Rerun\"),\n        Binding(\"t\", \"toggle_live\", \"Toggle Live Log\"),\n        Binding(\"v\", \"variables\", \"Variables\"),\n        Binding(\"ctrl+f\", \"search_content\", \"Search in Content\"),\n    ]\n\n    def __init__(\n        self,\n        host: str = DEFAULT_HOST,\n        port: int = DEFAULT_PORT,\n        refresh_interval: float = DEFAULT_REFRESH_INTERVAL,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the application.\n\n        Parameters\n        ----------\n        host : str, optional\n            The ecFlow server hostname, by default DEFAULT_HOST.\n        port : int, optional\n            The ecFlow server port, by default DEFAULT_PORT.\n        refresh_interval : float, optional\n            The interval for live log updates, by default DEFAULT_REFRESH_INTERVAL.\n        **kwargs : Any\n            Additional keyword arguments for the Textual App.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.host = host\n        self.port = port\n        self.refresh_interval = refresh_interval\n        self.ecflow_client: EcflowClient | None = None\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Compose the UI layout.\n\n        Returns\n        -------\n        ComposeResult\n            The UI components.\n        \"\"\"\n        yield Header(show_clock=True)\n        yield SearchBox(placeholder=\"Search nodes...\", id=\"search_box\")\n        yield Horizontal(\n            Container(SuiteTree(\"ecFlow Server\", id=\"suite_tree\"), id=\"sidebar\"),\n            MainContent(id=\"main_content\"),\n        )\n        yield StatusBar(id=\"status_bar\")\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        \"\"\"\n        Handle the mount event to start the application.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._initial_connect()\n        self.set_interval(self.refresh_interval, self._live_log_tick)\n\n    def on_tree_node_selected(self, event: SuiteTree.NodeSelected[str]) -&gt; None:\n        \"\"\"\n        Handle node selection to automatically load content.\n\n        Parameters\n        ----------\n        event : SuiteTree.NodeSelected[str]\n            The node selection event.\n        \"\"\"\n        if event.node.data:\n            self.action_load_node()\n\n    @work(thread=True)\n    def _initial_connect(self) -&gt; None:\n        \"\"\"\n        Perform initial connection to the ecFlow server.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        try:\n            self.ecflow_client = EcflowClient(self.host, self.port)\n            self.ecflow_client.ping()\n            # Initial refresh\n            self.action_refresh()\n        except RuntimeError as e:\n            self.call_from_thread(self.notify, f\"{ERROR_CONNECTION_FAILED}: {e}\", severity=\"error\", timeout=10)\n            tree = self.query_one(\"#suite_tree\", SuiteTree)\n            self.call_from_thread(self._update_tree_error, tree)\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def _update_tree_error(self, tree: SuiteTree) -&gt; None:\n        \"\"\"\n        Update tree root to show error.\n\n        Parameters\n        ----------\n        tree : SuiteTree\n            The suite tree widget.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        tree.root.label = f\"[red]{ERROR_CONNECTION_FAILED} (Check Host/Port)[/]\"\n\n    @work(exclusive=True, thread=True)\n    def action_refresh(self) -&gt; None:\n        \"\"\"\n        Fetch suites from server and rebuild the tree.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        if not self.ecflow_client:\n            return\n\n        self.call_from_thread(self.notify, \"Refreshing tree...\")\n\n        tree = self.query_one(\"#suite_tree\", SuiteTree)\n        status_bar = self.query_one(\"#status_bar\", StatusBar)\n        try:\n            self.ecflow_client.sync_local()\n            defs = self.ecflow_client.get_defs()\n            status = \"Connected\"\n            version = \"Unknown\"\n            if defs:\n                status = str(defs.get_server_state())\n            try:\n                version = self.ecflow_client.server_version()\n            except RuntimeError:\n                pass\n\n            self.call_from_thread(tree.update_tree, self.ecflow_client.host, self.ecflow_client.port, defs)\n            self.call_from_thread(\n                status_bar.update_status, self.ecflow_client.host, self.ecflow_client.port, status=status, version=version\n            )\n            self.call_from_thread(self.notify, \"Tree Refreshed\")\n        except RuntimeError as e:\n            self.call_from_thread(\n                status_bar.update_status, self.ecflow_client.host, self.ecflow_client.port, status=STATUS_SYNC_ERROR\n            )\n            self.call_from_thread(self.notify, f\"Refresh Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    @work(thread=True)\n    def action_restart_server(self) -&gt; None:\n        \"\"\"\n        Restart the ecFlow server (RUNNING).\n        \"\"\"\n        if not self.ecflow_client:\n            return\n        try:\n            self.ecflow_client.restart_server()\n            self.call_from_thread(self.notify, \"Server Started (RUNNING)\")\n            self.action_refresh()\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Restart Error: {e}\", severity=\"error\")\n\n    @work(thread=True)\n    def action_halt_server(self) -&gt; None:\n        \"\"\"\n        Halt the ecFlow server (HALT).\n        \"\"\"\n        if not self.ecflow_client:\n            return\n        try:\n            self.ecflow_client.halt_server()\n            self.call_from_thread(self.notify, \"Server Halted (HALT)\")\n            self.action_refresh()\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Halt Error: {e}\", severity=\"error\")\n\n    def get_selected_path(self) -&gt; str | None:\n        \"\"\"\n        Helper to get the ecFlow path of the selected node.\n\n        Returns\n        -------\n        str | None\n            The absolute path of the selected node, or None if no node is selected.\n        \"\"\"\n        try:\n            node = self.query_one(\"#suite_tree\", SuiteTree).cursor_node\n            return node.data if node else None\n        except Exception:\n            return None\n\n    @work(thread=True)\n    def action_load_node(self) -&gt; None:\n        \"\"\"Fetch Output, Script, and Job files for the selected node.\"\"\"\n        path = self.get_selected_path()\n        if not path or not self.ecflow_client:\n            self.call_from_thread(self.notify, \"No node selected\", severity=\"warning\")\n            return\n\n        self.call_from_thread(self.notify, f\"Loading files for {path}...\")\n        content_area = self.query_one(\"#main_content\", MainContent)\n\n        try:\n            # Sync to get latest try numbers for filenames\n            self.ecflow_client.sync_local()\n        except RuntimeError:\n            pass\n\n        # 1. Output Log\n        try:\n            content = self.ecflow_client.file(path, \"jobout\")\n            self.call_from_thread(content_area.update_log, content)\n        except RuntimeError:\n            self.call_from_thread(content_area.show_error, \"#log_output\", \"File type 'jobout' not found.\")\n\n        # 2. Script\n        try:\n            content = self.ecflow_client.file(path, \"script\")\n            self.call_from_thread(content_area.update_script, content)\n        except RuntimeError:\n            self.call_from_thread(content_area.show_error, \"#view_script\", \"File type 'script' not available.\")\n\n        # 3. Job\n        try:\n            content = self.ecflow_client.file(path, \"job\")\n            self.call_from_thread(content_area.update_job, content)\n        except RuntimeError:\n            self.call_from_thread(content_area.show_error, \"#view_job\", \"File type 'job' not available.\")\n\n    @work(thread=True)\n    def _run_client_command(self, command_name: str, path: str | None) -&gt; None:\n        \"\"\"\n        Generic helper to run ecflow commands in a worker thread.\n\n        Parameters\n        ----------\n        command_name : str\n            The name of the command to run on the EcflowClient.\n        path : str | None\n            The absolute path to the node.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        if not path or not self.ecflow_client:\n            return\n        try:\n            method = getattr(self.ecflow_client, command_name)\n            method(path)\n            self.call_from_thread(self.notify, f\"{command_name.replace('_', ' ').capitalize()}: {path}\")\n            self.action_refresh()\n        except RuntimeError as e:\n            self.call_from_thread(self.notify, f\"Command Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def action_suspend(self) -&gt; None:\n        \"\"\"\n        Suspend the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._run_client_command(\"suspend\", self.get_selected_path())\n\n    def action_resume(self) -&gt; None:\n        \"\"\"\n        Resume the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._run_client_command(\"resume\", self.get_selected_path())\n\n    def action_kill(self) -&gt; None:\n        \"\"\"\n        Kill the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._run_client_command(\"kill\", self.get_selected_path())\n\n    def action_force(self) -&gt; None:\n        \"\"\"\n        Force complete the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._run_client_command(\"force_complete\", self.get_selected_path())\n\n    def action_cycle_filter(self) -&gt; None:\n        \"\"\"\n        Cycle through tree filters.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.query_one(\"#suite_tree\", SuiteTree).action_cycle_filter()\n\n    def action_requeue(self) -&gt; None:\n        \"\"\"\n        Requeue the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self._run_client_command(\"requeue\", self.get_selected_path())\n\n    def action_copy_path(self) -&gt; None:\n        \"\"\"\n        Copy the selected node path to the clipboard.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        path = self.get_selected_path()\n        if path:\n            if hasattr(self, \"copy_to_clipboard\"):\n                self.copy_to_clipboard(path)\n                self.notify(f\"Copied to clipboard: {path}\")\n            else:\n                self.notify(f\"Node path: {path}\")\n        else:\n            self.notify(\"No node selected\", severity=\"warning\")\n\n    def action_toggle_live(self) -&gt; None:\n        \"\"\"\n        Toggle live log updates.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        content_area = self.query_one(\"#main_content\", MainContent)\n        content_area.is_live = not content_area.is_live\n        state = \"ON\" if content_area.is_live else \"OFF\"\n        self.notify(f\"Live Log: {state}\")\n        if content_area.is_live:\n            content_area.active = \"tab_output\"\n\n    @work(thread=True)\n    def _live_log_tick(self) -&gt; None:\n        \"\"\"Periodic tick to update the live log if enabled.\"\"\"\n        if not self.ecflow_client:\n            return\n        content_area = self.query_one(\"#main_content\", MainContent)\n        if content_area.is_live and content_area.active == \"tab_output\":\n            path = self.get_selected_path()\n            if path:\n                try:\n                    content = self.ecflow_client.file(path, \"jobout\")\n                    self.call_from_thread(content_area.update_log, content, append=True)\n                except RuntimeError:\n                    pass\n\n    def action_why(self) -&gt; None:\n        \"\"\"\n        Show the 'Why' inspector for the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        path = self.get_selected_path()\n        if not path or not self.ecflow_client:\n            self.notify(\"No node selected\", severity=\"warning\")\n            return\n        self.push_screen(WhyInspector(path, self.ecflow_client))\n\n    def action_variables(self) -&gt; None:\n        \"\"\"\n        Show the variable tweaker for the selected node.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        path = self.get_selected_path()\n        if not path or not self.ecflow_client:\n            self.notify(\"No node selected\", severity=\"warning\")\n            return\n        self.push_screen(VariableTweaker(path, self.ecflow_client))\n\n    def action_search_content(self) -&gt; None:\n        \"\"\"\n        Trigger content search in the main content area.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.query_one(\"#main_content\", MainContent).action_search()\n\n    @work(thread=True)\n    def action_edit_script(self) -&gt; None:\n        \"\"\"Open the node script in an editor and update it on the server.\"\"\"\n        path = self.get_selected_path()\n        if not path or not self.ecflow_client:\n            self.call_from_thread(self.notify, \"No node selected\", severity=\"warning\")\n            return\n\n        try:\n            content = self.ecflow_client.file(path, \"script\")\n            with tempfile.NamedTemporaryFile(suffix=\".ecf\", delete=False, mode=\"w\") as f:\n                f.write(content)\n                temp_path = f.name\n\n            self.call_from_thread(self._run_editor, temp_path, path, content)\n\n        except RuntimeError as e:\n            self.call_from_thread(self.notify, f\"Edit Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def _run_editor(self, temp_path: str, path: str, old_content: str) -&gt; None:\n        \"\"\"\n        Run the editor in a suspended state.\n\n        Parameters\n        ----------\n        temp_path : str\n            Path to the temporary file.\n        path : str\n            The ecFlow node path.\n        old_content : str\n            The original content of the script.\n        \"\"\"\n        editor = os.environ.get(\"EDITOR\", DEFAULT_EDITOR)\n        with self.suspend():\n            subprocess.run([editor, temp_path], check=False)\n\n        self._finish_edit(temp_path, path, old_content)\n\n    @work(thread=True)\n    def _finish_edit(self, temp_path: str, path: str, old_content: str) -&gt; None:\n        \"\"\"\n        Process the edited script and update the server.\n\n        Parameters\n        ----------\n        temp_path : str\n            Path to the temporary file.\n        path : str\n            The ecFlow node path.\n        old_content : str\n            The original content of the script.\n        \"\"\"\n        try:\n            with open(temp_path) as f:\n                new_content = f.read()\n\n            if os.path.exists(temp_path):\n                os.unlink(temp_path)\n\n            if new_content != old_content:\n                if self.ecflow_client:\n                    self.ecflow_client.alter(path, \"change\", \"script\", new_content)\n                    self.call_from_thread(self.notify, \"Script updated on server\")\n                    self.call_from_thread(self._prompt_requeue, path)\n            else:\n                self.call_from_thread(self.notify, \"No changes detected\")\n        except RuntimeError as e:\n            self.call_from_thread(self.notify, f\"Update Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def _prompt_requeue(self, path: str) -&gt; None:\n        \"\"\"\n        Prompt the user to requeue the node after a script edit.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n        \"\"\"\n        from ectop.widgets.modals.confirm import ConfirmModal\n\n        def do_requeue() -&gt; None:\n            if self.ecflow_client:\n                # We should probably run this in a worker too, but for simplicity\n                # we'll call a worker-wrapped method\n                self._run_client_command(\"requeue\", path)\n\n        self.push_screen(ConfirmModal(f\"Re-queue {path} now?\", do_requeue))\n\n    def action_search(self) -&gt; None:\n        \"\"\"\n        Show the search box.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        search_box = self.query_one(\"#search_box\", SearchBox)\n        search_box.add_class(\"visible\")\n        search_box.focus()\n\n    def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n        \"\"\"\n        Handle search submission.\n\n        Parameters\n        ----------\n        event : Input.Submitted\n            The input submission event.\n        \"\"\"\n        if event.input.id == \"search_box\":\n            query = event.value\n            if query:\n                tree = self.query_one(\"#suite_tree\", SuiteTree)\n                tree.find_and_select(query)\n\n    def on_input_changed(self, event: Input.Changed) -&gt; None:\n        \"\"\"\n        Handle search input changes for live search.\n\n        Parameters\n        ----------\n        event : Input.Changed\n            The input changed event.\n        \"\"\"\n        if event.input.id == \"search_box\":\n            query = event.value\n            if query:\n                tree = self.query_one(\"#suite_tree\", SuiteTree)\n                tree.find_and_select(query)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.__init__","level":3,"title":"<code>__init__(host=DEFAULT_HOST, port=DEFAULT_PORT, refresh_interval=DEFAULT_REFRESH_INTERVAL, **kwargs)</code>","text":"<p>Initialize the application.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.__init__--parameters","level":5,"title":"Parameters","text":"<p>host : str, optional     The ecFlow server hostname, by default DEFAULT_HOST. port : int, optional     The ecFlow server port, by default DEFAULT_PORT. refresh_interval : float, optional     The interval for live log updates, by default DEFAULT_REFRESH_INTERVAL. **kwargs : Any     Additional keyword arguments for the Textual App.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def __init__(\n    self,\n    host: str = DEFAULT_HOST,\n    port: int = DEFAULT_PORT,\n    refresh_interval: float = DEFAULT_REFRESH_INTERVAL,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the application.\n\n    Parameters\n    ----------\n    host : str, optional\n        The ecFlow server hostname, by default DEFAULT_HOST.\n    port : int, optional\n        The ecFlow server port, by default DEFAULT_PORT.\n    refresh_interval : float, optional\n        The interval for live log updates, by default DEFAULT_REFRESH_INTERVAL.\n    **kwargs : Any\n        Additional keyword arguments for the Textual App.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.host = host\n    self.port = port\n    self.refresh_interval = refresh_interval\n    self.ecflow_client: EcflowClient | None = None\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_copy_path","level":3,"title":"<code>action_copy_path()</code>","text":"<p>Copy the selected node path to the clipboard.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_copy_path--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_copy_path(self) -&gt; None:\n    \"\"\"\n    Copy the selected node path to the clipboard.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    path = self.get_selected_path()\n    if path:\n        if hasattr(self, \"copy_to_clipboard\"):\n            self.copy_to_clipboard(path)\n            self.notify(f\"Copied to clipboard: {path}\")\n        else:\n            self.notify(f\"Node path: {path}\")\n    else:\n        self.notify(\"No node selected\", severity=\"warning\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_cycle_filter","level":3,"title":"<code>action_cycle_filter()</code>","text":"<p>Cycle through tree filters.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_cycle_filter--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_cycle_filter(self) -&gt; None:\n    \"\"\"\n    Cycle through tree filters.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.query_one(\"#suite_tree\", SuiteTree).action_cycle_filter()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_edit_script","level":3,"title":"<code>action_edit_script()</code>","text":"<p>Open the node script in an editor and update it on the server.</p> Source code in <code>src/ectop/app.py</code> <pre><code>@work(thread=True)\ndef action_edit_script(self) -&gt; None:\n    \"\"\"Open the node script in an editor and update it on the server.\"\"\"\n    path = self.get_selected_path()\n    if not path or not self.ecflow_client:\n        self.call_from_thread(self.notify, \"No node selected\", severity=\"warning\")\n        return\n\n    try:\n        content = self.ecflow_client.file(path, \"script\")\n        with tempfile.NamedTemporaryFile(suffix=\".ecf\", delete=False, mode=\"w\") as f:\n            f.write(content)\n            temp_path = f.name\n\n        self.call_from_thread(self._run_editor, temp_path, path, content)\n\n    except RuntimeError as e:\n        self.call_from_thread(self.notify, f\"Edit Error: {e}\", severity=\"error\")\n    except Exception as e:\n        self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_force","level":3,"title":"<code>action_force()</code>","text":"<p>Force complete the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_force--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_force(self) -&gt; None:\n    \"\"\"\n    Force complete the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._run_client_command(\"force_complete\", self.get_selected_path())\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_halt_server","level":3,"title":"<code>action_halt_server()</code>","text":"<p>Halt the ecFlow server (HALT).</p> Source code in <code>src/ectop/app.py</code> <pre><code>@work(thread=True)\ndef action_halt_server(self) -&gt; None:\n    \"\"\"\n    Halt the ecFlow server (HALT).\n    \"\"\"\n    if not self.ecflow_client:\n        return\n    try:\n        self.ecflow_client.halt_server()\n        self.call_from_thread(self.notify, \"Server Halted (HALT)\")\n        self.action_refresh()\n    except Exception as e:\n        self.call_from_thread(self.notify, f\"Halt Error: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_kill","level":3,"title":"<code>action_kill()</code>","text":"<p>Kill the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_kill--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_kill(self) -&gt; None:\n    \"\"\"\n    Kill the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._run_client_command(\"kill\", self.get_selected_path())\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_load_node","level":3,"title":"<code>action_load_node()</code>","text":"<p>Fetch Output, Script, and Job files for the selected node.</p> Source code in <code>src/ectop/app.py</code> <pre><code>@work(thread=True)\ndef action_load_node(self) -&gt; None:\n    \"\"\"Fetch Output, Script, and Job files for the selected node.\"\"\"\n    path = self.get_selected_path()\n    if not path or not self.ecflow_client:\n        self.call_from_thread(self.notify, \"No node selected\", severity=\"warning\")\n        return\n\n    self.call_from_thread(self.notify, f\"Loading files for {path}...\")\n    content_area = self.query_one(\"#main_content\", MainContent)\n\n    try:\n        # Sync to get latest try numbers for filenames\n        self.ecflow_client.sync_local()\n    except RuntimeError:\n        pass\n\n    # 1. Output Log\n    try:\n        content = self.ecflow_client.file(path, \"jobout\")\n        self.call_from_thread(content_area.update_log, content)\n    except RuntimeError:\n        self.call_from_thread(content_area.show_error, \"#log_output\", \"File type 'jobout' not found.\")\n\n    # 2. Script\n    try:\n        content = self.ecflow_client.file(path, \"script\")\n        self.call_from_thread(content_area.update_script, content)\n    except RuntimeError:\n        self.call_from_thread(content_area.show_error, \"#view_script\", \"File type 'script' not available.\")\n\n    # 3. Job\n    try:\n        content = self.ecflow_client.file(path, \"job\")\n        self.call_from_thread(content_area.update_job, content)\n    except RuntimeError:\n        self.call_from_thread(content_area.show_error, \"#view_job\", \"File type 'job' not available.\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_refresh","level":3,"title":"<code>action_refresh()</code>","text":"<p>Fetch suites from server and rebuild the tree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_refresh--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_refresh--notes","level":5,"title":"Notes","text":"<p>This is a background worker that performs blocking I/O.</p> Source code in <code>src/ectop/app.py</code> <pre><code>@work(exclusive=True, thread=True)\ndef action_refresh(self) -&gt; None:\n    \"\"\"\n    Fetch suites from server and rebuild the tree.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This is a background worker that performs blocking I/O.\n    \"\"\"\n    if not self.ecflow_client:\n        return\n\n    self.call_from_thread(self.notify, \"Refreshing tree...\")\n\n    tree = self.query_one(\"#suite_tree\", SuiteTree)\n    status_bar = self.query_one(\"#status_bar\", StatusBar)\n    try:\n        self.ecflow_client.sync_local()\n        defs = self.ecflow_client.get_defs()\n        status = \"Connected\"\n        version = \"Unknown\"\n        if defs:\n            status = str(defs.get_server_state())\n        try:\n            version = self.ecflow_client.server_version()\n        except RuntimeError:\n            pass\n\n        self.call_from_thread(tree.update_tree, self.ecflow_client.host, self.ecflow_client.port, defs)\n        self.call_from_thread(\n            status_bar.update_status, self.ecflow_client.host, self.ecflow_client.port, status=status, version=version\n        )\n        self.call_from_thread(self.notify, \"Tree Refreshed\")\n    except RuntimeError as e:\n        self.call_from_thread(\n            status_bar.update_status, self.ecflow_client.host, self.ecflow_client.port, status=STATUS_SYNC_ERROR\n        )\n        self.call_from_thread(self.notify, f\"Refresh Error: {e}\", severity=\"error\")\n    except Exception as e:\n        self.call_from_thread(self.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_requeue","level":3,"title":"<code>action_requeue()</code>","text":"<p>Requeue the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_requeue--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_requeue(self) -&gt; None:\n    \"\"\"\n    Requeue the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._run_client_command(\"requeue\", self.get_selected_path())\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_restart_server","level":3,"title":"<code>action_restart_server()</code>","text":"<p>Restart the ecFlow server (RUNNING).</p> Source code in <code>src/ectop/app.py</code> <pre><code>@work(thread=True)\ndef action_restart_server(self) -&gt; None:\n    \"\"\"\n    Restart the ecFlow server (RUNNING).\n    \"\"\"\n    if not self.ecflow_client:\n        return\n    try:\n        self.ecflow_client.restart_server()\n        self.call_from_thread(self.notify, \"Server Started (RUNNING)\")\n        self.action_refresh()\n    except Exception as e:\n        self.call_from_thread(self.notify, f\"Restart Error: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_resume","level":3,"title":"<code>action_resume()</code>","text":"<p>Resume the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_resume--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_resume(self) -&gt; None:\n    \"\"\"\n    Resume the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._run_client_command(\"resume\", self.get_selected_path())\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_search","level":3,"title":"<code>action_search()</code>","text":"<p>Show the search box.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_search--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_search(self) -&gt; None:\n    \"\"\"\n    Show the search box.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    search_box = self.query_one(\"#search_box\", SearchBox)\n    search_box.add_class(\"visible\")\n    search_box.focus()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_search_content","level":3,"title":"<code>action_search_content()</code>","text":"<p>Trigger content search in the main content area.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_search_content--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_search_content(self) -&gt; None:\n    \"\"\"\n    Trigger content search in the main content area.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.query_one(\"#main_content\", MainContent).action_search()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_suspend","level":3,"title":"<code>action_suspend()</code>","text":"<p>Suspend the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_suspend--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_suspend(self) -&gt; None:\n    \"\"\"\n    Suspend the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._run_client_command(\"suspend\", self.get_selected_path())\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_toggle_live","level":3,"title":"<code>action_toggle_live()</code>","text":"<p>Toggle live log updates.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_toggle_live--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_toggle_live(self) -&gt; None:\n    \"\"\"\n    Toggle live log updates.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    content_area = self.query_one(\"#main_content\", MainContent)\n    content_area.is_live = not content_area.is_live\n    state = \"ON\" if content_area.is_live else \"OFF\"\n    self.notify(f\"Live Log: {state}\")\n    if content_area.is_live:\n        content_area.active = \"tab_output\"\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_variables","level":3,"title":"<code>action_variables()</code>","text":"<p>Show the variable tweaker for the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_variables--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_variables(self) -&gt; None:\n    \"\"\"\n    Show the variable tweaker for the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    path = self.get_selected_path()\n    if not path or not self.ecflow_client:\n        self.notify(\"No node selected\", severity=\"warning\")\n        return\n    self.push_screen(VariableTweaker(path, self.ecflow_client))\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_why","level":3,"title":"<code>action_why()</code>","text":"<p>Show the 'Why' inspector for the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.action_why--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def action_why(self) -&gt; None:\n    \"\"\"\n    Show the 'Why' inspector for the selected node.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    path = self.get_selected_path()\n    if not path or not self.ecflow_client:\n        self.notify(\"No node selected\", severity=\"warning\")\n        return\n    self.push_screen(WhyInspector(path, self.ecflow_client))\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.compose","level":3,"title":"<code>compose()</code>","text":"<p>Compose the UI layout.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.compose--returns","level":5,"title":"Returns","text":"<p>ComposeResult     The UI components.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Compose the UI layout.\n\n    Returns\n    -------\n    ComposeResult\n        The UI components.\n    \"\"\"\n    yield Header(show_clock=True)\n    yield SearchBox(placeholder=\"Search nodes...\", id=\"search_box\")\n    yield Horizontal(\n        Container(SuiteTree(\"ecFlow Server\", id=\"suite_tree\"), id=\"sidebar\"),\n        MainContent(id=\"main_content\"),\n    )\n    yield StatusBar(id=\"status_bar\")\n    yield Footer()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.get_selected_path","level":3,"title":"<code>get_selected_path()</code>","text":"<p>Helper to get the ecFlow path of the selected node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.get_selected_path--returns","level":5,"title":"Returns","text":"<p>str | None     The absolute path of the selected node, or None if no node is selected.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def get_selected_path(self) -&gt; str | None:\n    \"\"\"\n    Helper to get the ecFlow path of the selected node.\n\n    Returns\n    -------\n    str | None\n        The absolute path of the selected node, or None if no node is selected.\n    \"\"\"\n    try:\n        node = self.query_one(\"#suite_tree\", SuiteTree).cursor_node\n        return node.data if node else None\n    except Exception:\n        return None\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_input_changed","level":3,"title":"<code>on_input_changed(event)</code>","text":"<p>Handle search input changes for live search.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_input_changed--parameters","level":5,"title":"Parameters","text":"<p>event : Input.Changed     The input changed event.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def on_input_changed(self, event: Input.Changed) -&gt; None:\n    \"\"\"\n    Handle search input changes for live search.\n\n    Parameters\n    ----------\n    event : Input.Changed\n        The input changed event.\n    \"\"\"\n    if event.input.id == \"search_box\":\n        query = event.value\n        if query:\n            tree = self.query_one(\"#suite_tree\", SuiteTree)\n            tree.find_and_select(query)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_input_submitted","level":3,"title":"<code>on_input_submitted(event)</code>","text":"<p>Handle search submission.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_input_submitted--parameters","level":5,"title":"Parameters","text":"<p>event : Input.Submitted     The input submission event.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"\n    Handle search submission.\n\n    Parameters\n    ----------\n    event : Input.Submitted\n        The input submission event.\n    \"\"\"\n    if event.input.id == \"search_box\":\n        query = event.value\n        if query:\n            tree = self.query_one(\"#suite_tree\", SuiteTree)\n            tree.find_and_select(query)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_mount","level":3,"title":"<code>on_mount()</code>","text":"<p>Handle the mount event to start the application.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_mount--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Handle the mount event to start the application.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self._initial_connect()\n    self.set_interval(self.refresh_interval, self._live_log_tick)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_tree_node_selected","level":3,"title":"<code>on_tree_node_selected(event)</code>","text":"<p>Handle node selection to automatically load content.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.Ectop.on_tree_node_selected--parameters","level":5,"title":"Parameters","text":"<p>event : SuiteTree.NodeSelected[str]     The node selection event.</p> Source code in <code>src/ectop/app.py</code> <pre><code>def on_tree_node_selected(self, event: SuiteTree.NodeSelected[str]) -&gt; None:\n    \"\"\"\n    Handle node selection to automatically load content.\n\n    Parameters\n    ----------\n    event : SuiteTree.NodeSelected[str]\n        The node selection event.\n    \"\"\"\n    if event.node.data:\n        self.action_load_node()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.EctopCommands","level":2,"title":"<code>EctopCommands</code>","text":"<p>               Bases: <code>Provider</code></p> <p>Command provider for ectop.</p> Source code in <code>src/ectop/app.py</code> <pre><code>class EctopCommands(Provider):\n    \"\"\"\n    Command provider for ectop.\n    \"\"\"\n\n    async def search(self, query: str) -&gt; Hits:\n        \"\"\"\n        Search for commands.\n\n        Parameters\n        ----------\n        query : str\n            The search query.\n\n        Yields\n        ------\n        Hit\n            A command hit.\n        \"\"\"\n        matcher = self.matcher(query)\n        app = self.app\n        assert isinstance(app, Ectop)\n\n        commands = [\n            (\"Refresh Tree\", app.action_refresh, \"Refresh the ecFlow suite tree\"),\n            (\"Search Nodes\", app.action_search, \"Search for a node by name or path\"),\n            (\"Suspend Node\", app.action_suspend, \"Suspend the currently selected node\"),\n            (\"Resume Node\", app.action_resume, \"Resume the currently selected node\"),\n            (\"Kill Node\", app.action_kill, \"Kill the currently selected node\"),\n            (\"Force Complete\", app.action_force, \"Force complete the currently selected node\"),\n            (\"Cycle Filter\", app.action_cycle_filter, \"Cycle status filters (All, Aborted, Active...)\"),\n            (\"Requeue\", app.action_requeue, \"Requeue the currently selected node\"),\n            (\"Copy Path\", app.action_copy_path, \"Copy the selected node path\"),\n            (\"Why?\", app.action_why, \"Inspect why a node is not running\"),\n            (\"Variables\", app.action_variables, \"View/Edit node variables\"),\n            (\"Edit Script\", app.action_edit_script, \"Edit and rerun node script\"),\n            (\"Restart Server\", app.action_restart_server, \"Start server scheduling (RUNNING)\"),\n            (\"Halt Server\", app.action_halt_server, \"Stop server scheduling (HALT)\"),\n            (\"Toggle Live Log\", app.action_toggle_live, \"Toggle live log updates\"),\n            (\"Quit\", app.action_quit, \"Quit the application\"),\n        ]\n\n        for name, action, help_text in commands:\n            score = matcher.match(name)\n            if score &gt; 0:\n                yield Hit(\n                    score,\n                    matcher.highlight(name),\n                    action,\n                    help=help_text,\n                )\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.EctopCommands.search","level":3,"title":"<code>search(query)</code>  <code>async</code>","text":"<p>Search for commands.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.EctopCommands.search--parameters","level":5,"title":"Parameters","text":"<p>query : str     The search query.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.app.EctopCommands.search--yields","level":5,"title":"Yields","text":"<p>Hit     A command hit.</p> Source code in <code>src/ectop/app.py</code> <pre><code>async def search(self, query: str) -&gt; Hits:\n    \"\"\"\n    Search for commands.\n\n    Parameters\n    ----------\n    query : str\n        The search query.\n\n    Yields\n    ------\n    Hit\n        A command hit.\n    \"\"\"\n    matcher = self.matcher(query)\n    app = self.app\n    assert isinstance(app, Ectop)\n\n    commands = [\n        (\"Refresh Tree\", app.action_refresh, \"Refresh the ecFlow suite tree\"),\n        (\"Search Nodes\", app.action_search, \"Search for a node by name or path\"),\n        (\"Suspend Node\", app.action_suspend, \"Suspend the currently selected node\"),\n        (\"Resume Node\", app.action_resume, \"Resume the currently selected node\"),\n        (\"Kill Node\", app.action_kill, \"Kill the currently selected node\"),\n        (\"Force Complete\", app.action_force, \"Force complete the currently selected node\"),\n        (\"Cycle Filter\", app.action_cycle_filter, \"Cycle status filters (All, Aborted, Active...)\"),\n        (\"Requeue\", app.action_requeue, \"Requeue the currently selected node\"),\n        (\"Copy Path\", app.action_copy_path, \"Copy the selected node path\"),\n        (\"Why?\", app.action_why, \"Inspect why a node is not running\"),\n        (\"Variables\", app.action_variables, \"View/Edit node variables\"),\n        (\"Edit Script\", app.action_edit_script, \"Edit and rerun node script\"),\n        (\"Restart Server\", app.action_restart_server, \"Start server scheduling (RUNNING)\"),\n        (\"Halt Server\", app.action_halt_server, \"Stop server scheduling (HALT)\"),\n        (\"Toggle Live Log\", app.action_toggle_live, \"Toggle live log updates\"),\n        (\"Quit\", app.action_quit, \"Quit the application\"),\n    ]\n\n    for name, action, help_text in commands:\n        score = matcher.match(name)\n        if score &gt; 0:\n            yield Hit(\n                score,\n                matcher.highlight(name),\n                action,\n                help=help_text,\n            )\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient","level":2,"title":"<code>EcflowClient</code>","text":"<p>A wrapper around the ecflow.Client to provide a cleaner API and error handling.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient--attributes","level":4,"title":"Attributes","text":"<p>host : str     The hostname of the ecFlow server. port : int     The port number of the ecFlow server. client : ecflow.Client     The underlying ecFlow client instance.</p> Source code in <code>src/ectop/client.py</code> <pre><code>class EcflowClient:\n    \"\"\"\n    A wrapper around the ecflow.Client to provide a cleaner API and error handling.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n\n    Attributes\n    ----------\n    host : str\n        The hostname of the ecFlow server.\n    port : int\n        The port number of the ecFlow server.\n    client : ecflow.Client\n        The underlying ecFlow client instance.\n    \"\"\"\n\n    def __init__(self, host: str = \"localhost\", port: int = 3141) -&gt; None:\n        \"\"\"\n        Initialize the EcflowClient.\n\n        Parameters\n        ----------\n        host : str, optional\n            The hostname of the ecFlow server, by default \"localhost\".\n        port : int, optional\n            The port number of the ecFlow server, by default 3141.\n\n        Raises\n        ------\n        RuntimeError\n            If the ecFlow client cannot be initialized.\n        \"\"\"\n        self.host: str = host\n        self.port: int = port\n        try:\n            self.client: ecflow.Client = ecflow.Client(host, port)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to initialize ecFlow client for {host}:{port}: {e}\") from e\n\n    def ping(self) -&gt; None:\n        \"\"\"\n        Ping the ecFlow server to check connectivity.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If the server is unreachable or the ping fails.\n\n        Notes\n        -----\n        This is a blocking network call and should be run in a background worker.\n        \"\"\"\n        try:\n            self.client.ping()\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to ping ecFlow server at {self.host}:{self.port}: {e}\") from e\n\n    def sync_local(self) -&gt; None:\n        \"\"\"\n        Synchronize the local definition with the server.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If synchronization fails.\n\n        Notes\n        -----\n        This is a blocking network call and should be run in a background worker.\n        \"\"\"\n        try:\n            self.client.sync_local()\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to sync with ecFlow server: {e}\") from e\n\n    def get_defs(self) -&gt; Defs | None:\n        \"\"\"\n        Retrieve the current definitions from the client.\n\n        Returns\n        -------\n        ecflow.Defs | None\n            The ecFlow definitions, or None if not available.\n\n        Raises\n        ------\n        RuntimeError\n            If the definitions cannot be retrieved.\n        \"\"\"\n        try:\n            return self.client.get_defs()\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to get definitions from client: {e}\") from e\n\n    def file(self, path: str, file_type: str) -&gt; str:\n        \"\"\"\n        Retrieve a file (log, script, job) for a specific node.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n        file_type : str\n            The type of file to retrieve ('jobout', 'script', 'job').\n\n        Returns\n        -------\n        str\n            The content of the requested file.\n\n        Raises\n        ------\n        RuntimeError\n            If the file cannot be retrieved.\n        \"\"\"\n        try:\n            return self.client.get_file(path, file_type)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to retrieve {file_type} for {path}: {e}\") from e\n\n    def suspend(self, path: str) -&gt; None:\n        \"\"\"\n        Suspend a node.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n\n        Raises\n        ------\n        RuntimeError\n            If the node cannot be suspended.\n        \"\"\"\n        try:\n            self.client.suspend(path)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to suspend {path}: {e}\") from e\n\n    def resume(self, path: str) -&gt; None:\n        \"\"\"\n        Resume a suspended node.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n\n        Raises\n        ------\n        RuntimeError\n            If the node cannot be resumed.\n        \"\"\"\n        try:\n            self.client.resume(path)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to resume {path}: {e}\") from e\n\n    def kill(self, path: str) -&gt; None:\n        \"\"\"\n        Kill a running task.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n\n        Raises\n        ------\n        RuntimeError\n            If the node cannot be killed.\n        \"\"\"\n        try:\n            self.client.kill(path)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to kill {path}: {e}\") from e\n\n    def force_complete(self, path: str) -&gt; None:\n        \"\"\"\n        Force a node to the complete state.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n\n        Raises\n        ------\n        RuntimeError\n            If the node state cannot be forced.\n        \"\"\"\n        try:\n            self.client.force_complete(path)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to force complete {path}: {e}\") from e\n\n    def alter(self, path: str, alter_type: str, name: str, value: str = \"\") -&gt; None:\n        \"\"\"\n        Alter a node attribute or variable.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n        alter_type : str\n            The type of alteration (e.g., 'change', 'add', 'delete').\n        name : str\n            The name of the attribute or variable.\n        value : str, optional\n            The new value, by default \"\".\n\n        Raises\n        ------\n        RuntimeError\n            If the alteration fails.\n        \"\"\"\n        try:\n            self.client.alter(path, alter_type, name, value)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to alter {path} ({alter_type} {name}={value}): {e}\") from e\n\n    def requeue(self, path: str) -&gt; None:\n        \"\"\"\n        Requeue a node.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path to the node.\n\n        Raises\n        ------\n        RuntimeError\n            If the node cannot be requeued.\n        \"\"\"\n        try:\n            self.client.requeue(path)\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to requeue {path}: {e}\") from e\n\n    def restart_server(self) -&gt; None:\n        \"\"\"\n        Restart the ecFlow server (resume from HALTED state).\n\n        Raises\n        ------\n        RuntimeError\n            If the server cannot be restarted.\n        \"\"\"\n        try:\n            self.client.restart_server()\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to restart server: {e}\") from e\n\n    def halt_server(self) -&gt; None:\n        \"\"\"\n        Halt the ecFlow server (suspend scheduling).\n\n        Raises\n        ------\n        RuntimeError\n            If the server cannot be halted.\n        \"\"\"\n        try:\n            self.client.halt_server()\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to halt server: {e}\") from e\n\n    def version(self) -&gt; str:\n        \"\"\"\n        Retrieve the ecFlow client version.\n\n        Returns\n        -------\n        str\n            The client version string.\n\n        Raises\n        ------\n        RuntimeError\n            If the version cannot be retrieved.\n        \"\"\"\n        try:\n            return str(self.client.version())\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to get client version: {e}\") from e\n\n    def server_version(self) -&gt; str:\n        \"\"\"\n        Retrieve the ecFlow server version.\n\n        Returns\n        -------\n        str\n            The server version string.\n\n        Raises\n        ------\n        RuntimeError\n            If the server version cannot be retrieved.\n        \"\"\"\n        try:\n            return str(self.client.server_version())\n        except RuntimeError as e:\n            raise RuntimeError(f\"Failed to get server version: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.__init__","level":3,"title":"<code>__init__(host='localhost', port=3141)</code>","text":"<p>Initialize the EcflowClient.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.__init__--parameters","level":5,"title":"Parameters","text":"<p>host : str, optional     The hostname of the ecFlow server, by default \"localhost\". port : int, optional     The port number of the ecFlow server, by default 3141.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.__init__--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the ecFlow client cannot be initialized.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def __init__(self, host: str = \"localhost\", port: int = 3141) -&gt; None:\n    \"\"\"\n    Initialize the EcflowClient.\n\n    Parameters\n    ----------\n    host : str, optional\n        The hostname of the ecFlow server, by default \"localhost\".\n    port : int, optional\n        The port number of the ecFlow server, by default 3141.\n\n    Raises\n    ------\n    RuntimeError\n        If the ecFlow client cannot be initialized.\n    \"\"\"\n    self.host: str = host\n    self.port: int = port\n    try:\n        self.client: ecflow.Client = ecflow.Client(host, port)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to initialize ecFlow client for {host}:{port}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.alter","level":3,"title":"<code>alter(path, alter_type, name, value='')</code>","text":"<p>Alter a node attribute or variable.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.alter--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node. alter_type : str     The type of alteration (e.g., 'change', 'add', 'delete'). name : str     The name of the attribute or variable. value : str, optional     The new value, by default \"\".</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.alter--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the alteration fails.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def alter(self, path: str, alter_type: str, name: str, value: str = \"\") -&gt; None:\n    \"\"\"\n    Alter a node attribute or variable.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n    alter_type : str\n        The type of alteration (e.g., 'change', 'add', 'delete').\n    name : str\n        The name of the attribute or variable.\n    value : str, optional\n        The new value, by default \"\".\n\n    Raises\n    ------\n    RuntimeError\n        If the alteration fails.\n    \"\"\"\n    try:\n        self.client.alter(path, alter_type, name, value)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to alter {path} ({alter_type} {name}={value}): {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.file","level":3,"title":"<code>file(path, file_type)</code>","text":"<p>Retrieve a file (log, script, job) for a specific node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.file--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node. file_type : str     The type of file to retrieve ('jobout', 'script', 'job').</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.file--returns","level":5,"title":"Returns","text":"<p>str     The content of the requested file.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.file--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the file cannot be retrieved.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def file(self, path: str, file_type: str) -&gt; str:\n    \"\"\"\n    Retrieve a file (log, script, job) for a specific node.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n    file_type : str\n        The type of file to retrieve ('jobout', 'script', 'job').\n\n    Returns\n    -------\n    str\n        The content of the requested file.\n\n    Raises\n    ------\n    RuntimeError\n        If the file cannot be retrieved.\n    \"\"\"\n    try:\n        return self.client.get_file(path, file_type)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to retrieve {file_type} for {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.force_complete","level":3,"title":"<code>force_complete(path)</code>","text":"<p>Force a node to the complete state.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.force_complete--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.force_complete--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the node state cannot be forced.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def force_complete(self, path: str) -&gt; None:\n    \"\"\"\n    Force a node to the complete state.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n\n    Raises\n    ------\n    RuntimeError\n        If the node state cannot be forced.\n    \"\"\"\n    try:\n        self.client.force_complete(path)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to force complete {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.get_defs","level":3,"title":"<code>get_defs()</code>","text":"<p>Retrieve the current definitions from the client.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.get_defs--returns","level":5,"title":"Returns","text":"<p>ecflow.Defs | None     The ecFlow definitions, or None if not available.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.get_defs--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the definitions cannot be retrieved.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def get_defs(self) -&gt; Defs | None:\n    \"\"\"\n    Retrieve the current definitions from the client.\n\n    Returns\n    -------\n    ecflow.Defs | None\n        The ecFlow definitions, or None if not available.\n\n    Raises\n    ------\n    RuntimeError\n        If the definitions cannot be retrieved.\n    \"\"\"\n    try:\n        return self.client.get_defs()\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to get definitions from client: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.halt_server","level":3,"title":"<code>halt_server()</code>","text":"<p>Halt the ecFlow server (suspend scheduling).</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.halt_server--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the server cannot be halted.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def halt_server(self) -&gt; None:\n    \"\"\"\n    Halt the ecFlow server (suspend scheduling).\n\n    Raises\n    ------\n    RuntimeError\n        If the server cannot be halted.\n    \"\"\"\n    try:\n        self.client.halt_server()\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to halt server: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.kill","level":3,"title":"<code>kill(path)</code>","text":"<p>Kill a running task.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.kill--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.kill--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the node cannot be killed.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def kill(self, path: str) -&gt; None:\n    \"\"\"\n    Kill a running task.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n\n    Raises\n    ------\n    RuntimeError\n        If the node cannot be killed.\n    \"\"\"\n    try:\n        self.client.kill(path)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to kill {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.ping","level":3,"title":"<code>ping()</code>","text":"<p>Ping the ecFlow server to check connectivity.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.ping--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.ping--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the server is unreachable or the ping fails.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.ping--notes","level":5,"title":"Notes","text":"<p>This is a blocking network call and should be run in a background worker.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def ping(self) -&gt; None:\n    \"\"\"\n    Ping the ecFlow server to check connectivity.\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    RuntimeError\n        If the server is unreachable or the ping fails.\n\n    Notes\n    -----\n    This is a blocking network call and should be run in a background worker.\n    \"\"\"\n    try:\n        self.client.ping()\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to ping ecFlow server at {self.host}:{self.port}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.requeue","level":3,"title":"<code>requeue(path)</code>","text":"<p>Requeue a node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.requeue--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.requeue--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the node cannot be requeued.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def requeue(self, path: str) -&gt; None:\n    \"\"\"\n    Requeue a node.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n\n    Raises\n    ------\n    RuntimeError\n        If the node cannot be requeued.\n    \"\"\"\n    try:\n        self.client.requeue(path)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to requeue {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.restart_server","level":3,"title":"<code>restart_server()</code>","text":"<p>Restart the ecFlow server (resume from HALTED state).</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.restart_server--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the server cannot be restarted.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def restart_server(self) -&gt; None:\n    \"\"\"\n    Restart the ecFlow server (resume from HALTED state).\n\n    Raises\n    ------\n    RuntimeError\n        If the server cannot be restarted.\n    \"\"\"\n    try:\n        self.client.restart_server()\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to restart server: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.resume","level":3,"title":"<code>resume(path)</code>","text":"<p>Resume a suspended node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.resume--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.resume--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the node cannot be resumed.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def resume(self, path: str) -&gt; None:\n    \"\"\"\n    Resume a suspended node.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n\n    Raises\n    ------\n    RuntimeError\n        If the node cannot be resumed.\n    \"\"\"\n    try:\n        self.client.resume(path)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to resume {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.server_version","level":3,"title":"<code>server_version()</code>","text":"<p>Retrieve the ecFlow server version.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.server_version--returns","level":5,"title":"Returns","text":"<p>str     The server version string.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.server_version--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the server version cannot be retrieved.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def server_version(self) -&gt; str:\n    \"\"\"\n    Retrieve the ecFlow server version.\n\n    Returns\n    -------\n    str\n        The server version string.\n\n    Raises\n    ------\n    RuntimeError\n        If the server version cannot be retrieved.\n    \"\"\"\n    try:\n        return str(self.client.server_version())\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to get server version: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.suspend","level":3,"title":"<code>suspend(path)</code>","text":"<p>Suspend a node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.suspend--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path to the node.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.suspend--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the node cannot be suspended.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def suspend(self, path: str) -&gt; None:\n    \"\"\"\n    Suspend a node.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path to the node.\n\n    Raises\n    ------\n    RuntimeError\n        If the node cannot be suspended.\n    \"\"\"\n    try:\n        self.client.suspend(path)\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to suspend {path}: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.sync_local","level":3,"title":"<code>sync_local()</code>","text":"<p>Synchronize the local definition with the server.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.sync_local--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.sync_local--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If synchronization fails.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.sync_local--notes","level":5,"title":"Notes","text":"<p>This is a blocking network call and should be run in a background worker.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def sync_local(self) -&gt; None:\n    \"\"\"\n    Synchronize the local definition with the server.\n\n    Returns\n    -------\n    None\n\n    Raises\n    ------\n    RuntimeError\n        If synchronization fails.\n\n    Notes\n    -----\n    This is a blocking network call and should be run in a background worker.\n    \"\"\"\n    try:\n        self.client.sync_local()\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to sync with ecFlow server: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.version","level":3,"title":"<code>version()</code>","text":"<p>Retrieve the ecFlow client version.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.version--returns","level":5,"title":"Returns","text":"<p>str     The client version string.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.client.EcflowClient.version--raises","level":5,"title":"Raises","text":"<p>RuntimeError     If the version cannot be retrieved.</p> Source code in <code>src/ectop/client.py</code> <pre><code>def version(self) -&gt; str:\n    \"\"\"\n    Retrieve the ecFlow client version.\n\n    Returns\n    -------\n    str\n        The client version string.\n\n    Raises\n    ------\n    RuntimeError\n        If the version cannot be retrieved.\n    \"\"\"\n    try:\n        return str(self.client.version())\n    except RuntimeError as e:\n        raise RuntimeError(f\"Failed to get client version: {e}\") from e\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.cli.main","level":2,"title":"<code>main()</code>","text":"<p>Run the ectop application.</p> <p>Parses command-line arguments and environment variables for server configuration.</p> Source code in <code>src/ectop/cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Run the ectop application.\n\n    Parses command-line arguments and environment variables for server configuration.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"ectop  High-performance TUI for ECMWF ecFlow\")\n    parser.add_argument(\n        \"--host\",\n        type=str,\n        default=os.environ.get(\"ECF_HOST\", DEFAULT_HOST),\n        help=f\"ecFlow server hostname (default: {DEFAULT_HOST} or ECF_HOST)\",\n    )\n    parser.add_argument(\n        \"--port\",\n        type=int,\n        default=int(os.environ.get(\"ECF_PORT\", DEFAULT_PORT)),\n        help=f\"ecFlow server port (default: {DEFAULT_PORT} or ECF_PORT)\",\n    )\n    parser.add_argument(\n        \"--refresh\",\n        type=float,\n        default=float(os.environ.get(\"ECTOP_REFRESH\", DEFAULT_REFRESH_INTERVAL)),\n        help=f\"Automatic refresh interval in seconds (default: {DEFAULT_REFRESH_INTERVAL} or ECTOP_REFRESH)\",\n    )\n\n    args = parser.parse_args()\n\n    app = Ectop(host=args.host, port=args.port, refresh_interval=args.refresh)\n    app.run()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.DEFAULT_EDITOR","level":2,"title":"<code>DEFAULT_EDITOR = 'vi'</code>  <code>module-attribute</code>","text":"<p>Default editor for script editing.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.DEFAULT_SHELL","level":2,"title":"<code>DEFAULT_SHELL = 'bash'</code>  <code>module-attribute</code>","text":"<p>Default shell for script execution.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.ERROR_CONNECTION_FAILED","level":2,"title":"<code>ERROR_CONNECTION_FAILED = 'Connection Failed'</code>  <code>module-attribute</code>","text":"<p>Standard error message for connection failures.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.INHERITED_VAR_PREFIX","level":2,"title":"<code>INHERITED_VAR_PREFIX = 'inh_'</code>  <code>module-attribute</code>","text":"<p>Prefix for inherited variable keys in the VariableTweaker.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.LOADING_PLACEHOLDER","level":2,"title":"<code>LOADING_PLACEHOLDER = 'loading...'</code>  <code>module-attribute</code>","text":"<p>Placeholder text for lazy-loaded tree nodes.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.STATUS_SYNC_ERROR","level":2,"title":"<code>STATUS_SYNC_ERROR = 'Sync Error'</code>  <code>module-attribute</code>","text":"<p>Standard status message for synchronization errors.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.SYNTAX_THEME","level":2,"title":"<code>SYNTAX_THEME = 'monokai'</code>  <code>module-attribute</code>","text":"<p>Default theme for syntax highlighting.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.constants.TREE_FILTERS","level":2,"title":"<code>TREE_FILTERS = [None, 'aborted', 'active', 'queued', 'submitted', 'suspended']</code>  <code>module-attribute</code>","text":"<p>Default status filters for the SuiteTree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#widgets","level":2,"title":"Widgets","text":"<p>Main content area for displaying ecFlow node information.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Search box widget for finding nodes in the suite tree.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Sidebar widget for the ecFlow suite tree.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Status bar widget for ectop.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent","level":2,"title":"<code>MainContent</code>","text":"<p>               Bases: <code>Vertical</code></p> <p>A container to display Output logs, Scripts, and Job files in tabs.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent--attributes","level":4,"title":"Attributes","text":"<p>is_live : bool     Whether live log updates are enabled. last_log_size : int     The size of the log content at the last update.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>class MainContent(Vertical):\n    \"\"\"\n    A container to display Output logs, Scripts, and Job files in tabs.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n\n    Attributes\n    ----------\n    is_live : bool\n        Whether live log updates are enabled.\n    last_log_size : int\n        The size of the log content at the last update.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the MainContent widget.\n\n        Parameters\n        ----------\n        *args : Any\n            Positional arguments for Vertical.\n        **kwargs : Any\n            Keyword arguments for Vertical.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.is_live: bool = False\n        self.last_log_size: int = 0\n        self._content_cache: dict[str, str] = {}\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Compose the tabs for Output, Script, and Job.\n\n        Returns\n        -------\n        ComposeResult\n            The UI components for the tabs.\n        \"\"\"\n        yield Input(placeholder=\"Search in content...\", id=\"content_search\", classes=\"hidden\")\n        with TabbedContent(id=\"content_tabs\"):\n            with TabPane(\"Output\", id=\"tab_output\"):\n                yield RichLog(markup=True, highlight=True, id=\"log_output\")\n            with TabPane(\"Script (.ecf)\", id=\"tab_script\"):\n                with VerticalScroll():\n                    yield Static(\"\", id=\"view_script\", classes=\"code_view\")\n            with TabPane(\"Job (Processed)\", id=\"tab_job\"):\n                with VerticalScroll():\n                    yield Static(\"\", id=\"view_job\", classes=\"code_view\")\n\n    @property\n    def active(self) -&gt; str | None:\n        \"\"\"\n        Get the active tab ID.\n\n        Returns\n        -------\n        str | None\n            The ID of the active tab.\n        \"\"\"\n        return self.query_one(\"#content_tabs\", TabbedContent).active\n\n    @active.setter\n    def active(self, value: str) -&gt; None:\n        \"\"\"\n        Set the active tab ID.\n\n        Parameters\n        ----------\n        value : str\n            The ID of the tab to activate.\n        \"\"\"\n        self.query_one(\"#content_tabs\", TabbedContent).active = value\n\n    def update_log(self, content: str, append: bool = False) -&gt; None:\n        \"\"\"\n        Update the Output log tab.\n\n        Parameters\n        ----------\n        content : str\n            The content to display or append.\n        append : bool, optional\n            Whether to append to existing content, by default False.\n        \"\"\"\n        widget = self.query_one(\"#log_output\", RichLog)\n        self._content_cache[\"output\"] = content\n        if not append:\n            widget.clear()\n            self.last_log_size = len(content)\n            widget.write(content)\n        else:\n            new_content = content[self.last_log_size :]\n            if new_content:\n                widget.write(new_content)\n                self.last_log_size = len(content)\n\n    def update_script(self, content: str) -&gt; None:\n        \"\"\"\n        Update the Script tab with syntax highlighting.\n\n        Parameters\n        ----------\n        content : str\n            The script content.\n        \"\"\"\n        self._content_cache[\"script\"] = content\n        widget = self.query_one(\"#view_script\", Static)\n        syntax = Syntax(content, \"bash\", theme=SYNTAX_THEME, line_numbers=True)\n        widget.update(syntax)\n\n    def update_job(self, content: str) -&gt; None:\n        \"\"\"\n        Update the Job tab with syntax highlighting.\n\n        Parameters\n        ----------\n        content : str\n            The job content.\n        \"\"\"\n        self._content_cache[\"job\"] = content\n        widget = self.query_one(\"#view_job\", Static)\n        syntax = Syntax(content, \"bash\", theme=SYNTAX_THEME, line_numbers=True)\n        widget.update(syntax)\n\n    def action_search(self) -&gt; None:\n        \"\"\"\n        Toggle the content search input.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        search_input = self.query_one(\"#content_search\", Input)\n        if \"hidden\" in search_input.classes:\n            search_input.remove_class(\"hidden\")\n            search_input.focus()\n        else:\n            search_input.add_class(\"hidden\")\n            # Refocus the active tab's content\n            active_tab = self.active\n            if active_tab == \"tab_output\":\n                self.query_one(\"#log_output\").focus()\n\n    def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n        \"\"\"\n        Handle content search submission.\n\n        Parameters\n        ----------\n        event : Input.Submitted\n            The input submission event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if event.input.id == \"content_search\":\n            query = event.value\n            if not query:\n                return\n\n            active_tab = self.active\n            cache_key = \"output\"\n            if active_tab == \"tab_script\":\n                cache_key = \"script\"\n            elif active_tab == \"tab_job\":\n                cache_key = \"job\"\n\n            content = self._content_cache.get(cache_key, \"\")\n            matches = content.lower().count(query.lower())\n            self.app.notify(f\"Found {matches} matches for '{query}' in {cache_key}\")\n\n    def show_error(self, widget_id: str, message: str) -&gt; None:\n        \"\"\"\n        Display an error message in a specific widget.\n\n        Parameters\n        ----------\n        widget_id : str\n            The ID of the widget where the error should be shown.\n        message : str\n            The error message to display.\n        \"\"\"\n        widget = self.query_one(widget_id)\n        if isinstance(widget, RichLog):\n            widget.write(f\"[italic red]{message}[/]\")\n        elif isinstance(widget, Static):\n            widget.update(f\"[italic red]{message}[/]\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.active","level":3,"title":"<code>active</code>  <code>property</code> <code>writable</code>","text":"<p>Get the active tab ID.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.active--returns","level":5,"title":"Returns","text":"<p>str | None     The ID of the active tab.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.__init__","level":3,"title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the MainContent widget.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.__init__--parameters","level":5,"title":"Parameters","text":"<p>args : Any     Positional arguments for Vertical. *kwargs : Any     Keyword arguments for Vertical.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the MainContent widget.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments for Vertical.\n    **kwargs : Any\n        Keyword arguments for Vertical.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.is_live: bool = False\n    self.last_log_size: int = 0\n    self._content_cache: dict[str, str] = {}\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.action_search","level":3,"title":"<code>action_search()</code>","text":"<p>Toggle the content search input.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.action_search--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def action_search(self) -&gt; None:\n    \"\"\"\n    Toggle the content search input.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    search_input = self.query_one(\"#content_search\", Input)\n    if \"hidden\" in search_input.classes:\n        search_input.remove_class(\"hidden\")\n        search_input.focus()\n    else:\n        search_input.add_class(\"hidden\")\n        # Refocus the active tab's content\n        active_tab = self.active\n        if active_tab == \"tab_output\":\n            self.query_one(\"#log_output\").focus()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.compose","level":3,"title":"<code>compose()</code>","text":"<p>Compose the tabs for Output, Script, and Job.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.compose--returns","level":5,"title":"Returns","text":"<p>ComposeResult     The UI components for the tabs.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Compose the tabs for Output, Script, and Job.\n\n    Returns\n    -------\n    ComposeResult\n        The UI components for the tabs.\n    \"\"\"\n    yield Input(placeholder=\"Search in content...\", id=\"content_search\", classes=\"hidden\")\n    with TabbedContent(id=\"content_tabs\"):\n        with TabPane(\"Output\", id=\"tab_output\"):\n            yield RichLog(markup=True, highlight=True, id=\"log_output\")\n        with TabPane(\"Script (.ecf)\", id=\"tab_script\"):\n            with VerticalScroll():\n                yield Static(\"\", id=\"view_script\", classes=\"code_view\")\n        with TabPane(\"Job (Processed)\", id=\"tab_job\"):\n            with VerticalScroll():\n                yield Static(\"\", id=\"view_job\", classes=\"code_view\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.on_input_submitted","level":3,"title":"<code>on_input_submitted(event)</code>","text":"<p>Handle content search submission.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.on_input_submitted--parameters","level":5,"title":"Parameters","text":"<p>event : Input.Submitted     The input submission event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.on_input_submitted--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"\n    Handle content search submission.\n\n    Parameters\n    ----------\n    event : Input.Submitted\n        The input submission event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if event.input.id == \"content_search\":\n        query = event.value\n        if not query:\n            return\n\n        active_tab = self.active\n        cache_key = \"output\"\n        if active_tab == \"tab_script\":\n            cache_key = \"script\"\n        elif active_tab == \"tab_job\":\n            cache_key = \"job\"\n\n        content = self._content_cache.get(cache_key, \"\")\n        matches = content.lower().count(query.lower())\n        self.app.notify(f\"Found {matches} matches for '{query}' in {cache_key}\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.show_error","level":3,"title":"<code>show_error(widget_id, message)</code>","text":"<p>Display an error message in a specific widget.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.show_error--parameters","level":5,"title":"Parameters","text":"<p>widget_id : str     The ID of the widget where the error should be shown. message : str     The error message to display.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def show_error(self, widget_id: str, message: str) -&gt; None:\n    \"\"\"\n    Display an error message in a specific widget.\n\n    Parameters\n    ----------\n    widget_id : str\n        The ID of the widget where the error should be shown.\n    message : str\n        The error message to display.\n    \"\"\"\n    widget = self.query_one(widget_id)\n    if isinstance(widget, RichLog):\n        widget.write(f\"[italic red]{message}[/]\")\n    elif isinstance(widget, Static):\n        widget.update(f\"[italic red]{message}[/]\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_job","level":3,"title":"<code>update_job(content)</code>","text":"<p>Update the Job tab with syntax highlighting.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_job--parameters","level":5,"title":"Parameters","text":"<p>content : str     The job content.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def update_job(self, content: str) -&gt; None:\n    \"\"\"\n    Update the Job tab with syntax highlighting.\n\n    Parameters\n    ----------\n    content : str\n        The job content.\n    \"\"\"\n    self._content_cache[\"job\"] = content\n    widget = self.query_one(\"#view_job\", Static)\n    syntax = Syntax(content, \"bash\", theme=SYNTAX_THEME, line_numbers=True)\n    widget.update(syntax)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_log","level":3,"title":"<code>update_log(content, append=False)</code>","text":"<p>Update the Output log tab.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_log--parameters","level":5,"title":"Parameters","text":"<p>content : str     The content to display or append. append : bool, optional     Whether to append to existing content, by default False.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def update_log(self, content: str, append: bool = False) -&gt; None:\n    \"\"\"\n    Update the Output log tab.\n\n    Parameters\n    ----------\n    content : str\n        The content to display or append.\n    append : bool, optional\n        Whether to append to existing content, by default False.\n    \"\"\"\n    widget = self.query_one(\"#log_output\", RichLog)\n    self._content_cache[\"output\"] = content\n    if not append:\n        widget.clear()\n        self.last_log_size = len(content)\n        widget.write(content)\n    else:\n        new_content = content[self.last_log_size :]\n        if new_content:\n            widget.write(new_content)\n            self.last_log_size = len(content)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_script","level":3,"title":"<code>update_script(content)</code>","text":"<p>Update the Script tab with syntax highlighting.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.content.MainContent.update_script--parameters","level":5,"title":"Parameters","text":"<p>content : str     The script content.</p> Source code in <code>src/ectop/widgets/content.py</code> <pre><code>def update_script(self, content: str) -&gt; None:\n    \"\"\"\n    Update the Script tab with syntax highlighting.\n\n    Parameters\n    ----------\n    content : str\n        The script content.\n    \"\"\"\n    self._content_cache[\"script\"] = content\n    widget = self.query_one(\"#view_script\", Static)\n    syntax = Syntax(content, \"bash\", theme=SYNTAX_THEME, line_numbers=True)\n    widget.update(syntax)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.search.SearchBox","level":2,"title":"<code>SearchBox</code>","text":"<p>               Bases: <code>Input</code></p> <p>An input widget for searching nodes in the tree.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/search.py</code> <pre><code>class SearchBox(Input):\n    \"\"\"\n    An input widget for searching nodes in the tree.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"cancel\", \"Cancel Search\"),\n        Binding(\"enter\", \"submit\", \"Search Next\"),\n    ]\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the SearchBox.\n\n        Parameters\n        ----------\n        *args : Any\n            Positional arguments for the Input widget.\n        **kwargs : Any\n            Keyword arguments for the Input widget.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def action_cancel(self) -&gt; None:\n        \"\"\"\n        Clear search, hide box, and return focus to the tree.\n        \"\"\"\n        self.value = \"\"\n        self.remove_class(\"visible\")\n        self.app.set_focus(self.app.query_one(\"#suite_tree\"))\n\n    def on_blur(self) -&gt; None:\n        \"\"\"\n        Hide the search box when it loses focus.\n        \"\"\"\n        self.remove_class(\"visible\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.search.SearchBox.__init__","level":3,"title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the SearchBox.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.search.SearchBox.__init__--parameters","level":5,"title":"Parameters","text":"<p>args : Any     Positional arguments for the Input widget. *kwargs : Any     Keyword arguments for the Input widget.</p> Source code in <code>src/ectop/widgets/search.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the SearchBox.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments for the Input widget.\n    **kwargs : Any\n        Keyword arguments for the Input widget.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.search.SearchBox.action_cancel","level":3,"title":"<code>action_cancel()</code>","text":"<p>Clear search, hide box, and return focus to the tree.</p> Source code in <code>src/ectop/widgets/search.py</code> <pre><code>def action_cancel(self) -&gt; None:\n    \"\"\"\n    Clear search, hide box, and return focus to the tree.\n    \"\"\"\n    self.value = \"\"\n    self.remove_class(\"visible\")\n    self.app.set_focus(self.app.query_one(\"#suite_tree\"))\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.search.SearchBox.on_blur","level":3,"title":"<code>on_blur()</code>","text":"<p>Hide the search box when it loses focus.</p> Source code in <code>src/ectop/widgets/search.py</code> <pre><code>def on_blur(self) -&gt; None:\n    \"\"\"\n    Hide the search box when it loses focus.\n    \"\"\"\n    self.remove_class(\"visible\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree","level":2,"title":"<code>SuiteTree</code>","text":"<p>               Bases: <code>Tree[str]</code></p> <p>A tree widget to display ecFlow suites and nodes.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>class SuiteTree(Tree[str]):\n    \"\"\"\n    A tree widget to display ecFlow suites and nodes.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the SuiteTree.\n\n        Parameters\n        ----------\n        *args : Any\n            Positional arguments for the Tree widget.\n        **kwargs : Any\n            Keyword arguments for the Tree widget.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.defs: Defs | None = None\n        self.current_filter: str | None = None\n        self.filters: list[str | None] = TREE_FILTERS\n        self.host: str = \"\"\n        self.port: int = 0\n\n    def update_tree(self, client_host: str, client_port: int, defs: Defs | None) -&gt; None:\n        \"\"\"\n        Rebuild the tree from ecFlow definitions using lazy loading.\n\n        Parameters\n        ----------\n        client_host : str\n            The hostname of the ecFlow server.\n        client_port : int\n            The port of the ecFlow server.\n        defs : ecflow.Defs | None\n            The ecFlow definitions to display.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method is typically called from the main thread after a sync.\n        \"\"\"\n        self.host = client_host\n        self.port = client_port\n        self.defs = defs\n        self._all_paths_cache: list[str] | None = None\n        self.clear()\n        if not defs:\n            self.root.label = \"Server Empty\"\n            return\n\n        filter_str = f\" [Filter: {self.current_filter}]\" if self.current_filter else \"\"\n        self.root.label = f\"{ICON_SERVER} {client_host}:{client_port}{filter_str}\"\n\n        # Start background worker for tree population to avoid blocking UI\n        self._populate_tree_worker()\n\n        # Trigger background cache building for search\n        self._build_all_paths_cache_worker()\n\n    @work(thread=True)\n    def _populate_tree_worker(self) -&gt; None:\n        \"\"\"\n        Worker to populate the tree root with suites in a background thread.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs recursive filtering.\n        \"\"\"\n        if not self.defs:\n            return\n        for suite in self.defs.suites:\n            if self._should_show_node(suite):\n                self._safe_call(self._add_node_to_ui, self.root, suite)\n\n    def _should_show_node(self, node: Node) -&gt; bool:\n        \"\"\"\n        Determine if a node should be shown based on the current filter.\n\n        Parameters\n        ----------\n        node : ecflow.Node\n            The ecFlow node to check.\n\n        Returns\n        -------\n        bool\n            True if the node or any of its descendants match the filter.\n        \"\"\"\n        if not self.current_filter:\n            return True\n\n        state = str(node.get_state())\n        if state == self.current_filter:\n            return True\n\n        if hasattr(node, \"nodes\"):\n            return any(self._should_show_node(child) for child in node.nodes)\n\n        return False\n\n    @work(thread=True)\n    def _build_all_paths_cache_worker(self) -&gt; None:\n        \"\"\"\n        Worker to build the node path cache in a background thread.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This cache is used by find_and_select to provide fast search without\n        blocking the UI thread on the first search.\n        \"\"\"\n        if not self.defs:\n            return\n\n        paths: list[str] = []\n        for suite in self.defs.suites:\n            paths.append(suite.get_abs_node_path())\n            for node in suite.get_all_nodes():\n                paths.append(node.get_abs_node_path())\n\n        self._all_paths_cache = paths\n\n    def action_cycle_filter(self) -&gt; None:\n        \"\"\"\n        Cycle through available status filters and refresh the tree.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        current_idx = self.filters.index(self.current_filter)\n        next_idx = (current_idx + 1) % len(self.filters)\n        self.current_filter = self.filters[next_idx]\n\n        # We need to refresh the tree from local defs\n        if self.defs:\n            self.update_tree(self.host, self.port, self.defs)\n\n        self.app.notify(f\"Filter: {self.current_filter or 'All'}\")\n\n    def _add_node_to_ui(self, parent_ui_node: TreeNode[str], ecflow_node: Node) -&gt; TreeNode[str]:\n        \"\"\"\n        Add a single ecflow node to the UI tree.\n\n        Parameters\n        ----------\n        parent_ui_node : TreeNode[str]\n            The parent node in the Textual tree.\n        ecflow_node : ecflow.Node\n            The ecFlow node to add.\n\n        Returns\n        -------\n        TreeNode[str]\n            The newly created UI node.\n        \"\"\"\n        state = str(ecflow_node.get_state())\n        icon = STATE_MAP.get(state, ICON_UNKNOWN_STATE)\n\n        is_container = isinstance(ecflow_node, (ecflow.Family, ecflow.Suite))\n        type_icon = ICON_FAMILY if is_container else ICON_TASK\n\n        label = Text(f\"{icon} {type_icon} {ecflow_node.name()} \")\n        label.append(f\"[{state}]\", style=\"bold italic\")\n\n        new_ui_node = parent_ui_node.add(\n            label,\n            data=ecflow_node.get_abs_node_path(),\n            expand=False,\n        )\n\n        # If it's a container and has children, add a placeholder for lazy loading\n        if is_container and hasattr(ecflow_node, \"nodes\"):\n            # Use a more efficient check for presence of children than len(list(...))\n            has_children = False\n            try:\n                # Check if there is at least one child\n                next(iter(ecflow_node.nodes))\n                has_children = True\n            except (StopIteration, RuntimeError):\n                pass\n\n            if has_children:\n                new_ui_node.add(LOADING_PLACEHOLDER, allow_expand=False)\n\n        return new_ui_node\n\n    def on_tree_node_expanded(self, event: Tree.NodeExpanded[str]) -&gt; None:\n        \"\"\"\n        Handle node expansion to load children on demand.\n\n        Parameters\n        ----------\n        event : Tree.NodeExpanded[str]\n            The expansion event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        node = event.node\n        self._load_children(node)\n\n    def _load_children(self, ui_node: TreeNode[str], sync: bool = False) -&gt; None:\n        \"\"\"\n        Load children for a UI node if they haven't been loaded yet.\n\n        Parameters\n        ----------\n        ui_node : TreeNode[str]\n            The UI node to load children for.\n        sync : bool, optional\n            Whether to load children synchronously, by default False.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        None\n\n        Notes\n        -----\n        Uses `_load_children_worker` for async loading.\n        \"\"\"\n        if not ui_node.data or not self.defs:\n            return\n\n        # Check if we have the placeholder\n        if len(ui_node.children) == 1 and str(ui_node.children[0].label) == LOADING_PLACEHOLDER:\n            # UI modification must be scheduled on the main thread\n            placeholder = ui_node.children[0]\n            self._safe_call(placeholder.remove)\n\n            if sync:\n                ecflow_node = self.defs.find_abs_node(ui_node.data)\n                if ecflow_node and hasattr(ecflow_node, \"nodes\"):\n                    for child in ecflow_node.nodes:\n                        self._safe_call(self._add_node_to_ui, ui_node, child)\n            else:\n                self._load_children_worker(ui_node, ui_node.data)\n\n    @work(thread=True)\n    def _load_children_worker(self, ui_node: TreeNode[str], node_path: str) -&gt; None:\n        \"\"\"\n        Worker to load children nodes in a background thread.\n\n        Parameters\n        ----------\n        ui_node : TreeNode[str]\n            The UI node to populate.\n        node_path : str\n            The absolute path of the ecFlow node.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        UI updates are scheduled back to the main thread using `call_from_thread`.\n        \"\"\"\n        if not self.defs:\n            return\n\n        ecflow_node = self.defs.find_abs_node(node_path)\n        if ecflow_node and hasattr(ecflow_node, \"nodes\"):\n            for child in ecflow_node.nodes:\n                if self._should_show_node(child):\n                    self.app.call_from_thread(self._add_node_to_ui, ui_node, child)\n\n    @work(exclusive=True, thread=True)\n    def find_and_select(self, query: str) -&gt; None:\n        \"\"\"\n        Find nodes matching query in the ecFlow definitions and select them.\n\n        This handles searching through unloaded parts of the tree in a\n        background thread to keep the UI responsive.\n\n        Parameters\n        ----------\n        query : str\n            The search query.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker.\n        \"\"\"\n        self._find_and_select_logic(query)\n\n    def _find_and_select_logic(self, query: str) -&gt; None:\n        \"\"\"\n        The actual search logic split out for testing.\n\n        Parameters\n        ----------\n        query : str\n            The search query.\n        \"\"\"\n        if not self.defs:\n            return\n\n        query = query.lower()\n\n        # Build or use cached paths\n        if not hasattr(self, \"_all_paths_cache\") or self._all_paths_cache is None:\n            # Fallback if cache isn't ready yet (e.g. searching immediately after sync)\n            paths: list[str] = []\n            for suite in self.defs.suites:\n                paths.append(suite.get_abs_node_path())\n                for node in suite.get_all_nodes():\n                    paths.append(node.get_abs_node_path())\n            self._all_paths_cache = paths\n\n        all_paths = self._all_paths_cache\n\n        # Get current cursor state on main thread\n        cursor_node = getattr(self, \"cursor_node\", None)\n        current_path = cursor_node.data if cursor_node else None\n\n        start_index = 0\n        if current_path and current_path in all_paths:\n            try:\n                start_index = all_paths.index(current_path) + 1\n            except ValueError:\n                start_index = 0\n\n        # Search from start_index to end, then wrap around\n        found_path = None\n        for i in range(len(all_paths)):\n            path = all_paths[(start_index + i) % len(all_paths)]\n            if query in path.lower():\n                found_path = path\n                break\n\n        if found_path:\n            self._select_by_path_logic(found_path)\n        else:\n            self._safe_call(self.app.notify, f\"No match found for '{query}'\", severity=\"warning\")\n\n    def _safe_call(self, callback: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Safely call a UI-related function from either the main thread or a worker.\n\n        Parameters\n        ----------\n        callback : Callable[..., Any]\n            The function to call.\n        *args : Any\n            Positional arguments.\n        **kwargs : Any\n            Keyword arguments.\n\n        Returns\n        -------\n        Any\n            The result of the call if synchronous, or None if scheduled.\n        \"\"\"\n        try:\n            # Check if we are on the main thread.\n            # Using private access as Textual doesn't provide a public way yet.\n            if self.app._thread_id == threading.get_ident():\n                return callback(*args, **kwargs)\n        except (AttributeError, RuntimeError):\n            # App might not be fully initialized in some tests\n            pass\n\n        return self.app.call_from_thread(callback, *args, **kwargs)\n\n    @work(thread=True)\n    def select_by_path(self, path: str) -&gt; None:\n        \"\"\"\n        Select a node by its absolute ecFlow path, expanding parents as needed.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path of the node to select.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker to avoid blocking the UI thread when\n        loading many nested nodes synchronously.\n        \"\"\"\n        self._select_by_path_logic(path)\n\n    def _select_by_path_logic(self, path: str) -&gt; None:\n        \"\"\"\n        The actual logic for selecting a node by path.\n\n        Parameters\n        ----------\n        path : str\n            The absolute path of the node to select.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This method should be called from a background thread as it performs\n        synchronous child loading.\n        \"\"\"\n        if path == \"/\":\n            self.app.call_from_thread(self.select_node, self.root)\n            return\n\n        parts = path.strip(\"/\").split(\"/\")\n        current_ui_node = self.root\n\n        current_path = \"\"\n        for part in parts:\n            current_path += \"/\" + part\n            # Load children synchronously within the worker thread\n            self._load_children(current_ui_node, sync=True)\n            self._safe_call(current_ui_node.expand)\n\n            found = False\n            for child in current_ui_node.children:\n                if child.data == current_path:\n                    current_ui_node = child\n                    found = True\n                    break\n            if not found:\n                return\n\n        self._safe_call(self._select_and_reveal, current_ui_node)\n\n    def _select_and_reveal(self, node: TreeNode[str]) -&gt; None:\n        \"\"\"\n        Select a node and expand all its parents.\n\n        Parameters\n        ----------\n        node : TreeNode[str]\n            The node to select and reveal.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.select_node(node)\n        parent = node.parent\n        while parent:\n            parent.expand()\n            parent = parent.parent\n        self.scroll_to_node(node)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.__init__","level":3,"title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the SuiteTree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.__init__--parameters","level":5,"title":"Parameters","text":"<p>args : Any     Positional arguments for the Tree widget. *kwargs : Any     Keyword arguments for the Tree widget.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.__init__--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the SuiteTree.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments for the Tree widget.\n    **kwargs : Any\n        Keyword arguments for the Tree widget.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.defs: Defs | None = None\n    self.current_filter: str | None = None\n    self.filters: list[str | None] = TREE_FILTERS\n    self.host: str = \"\"\n    self.port: int = 0\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.action_cycle_filter","level":3,"title":"<code>action_cycle_filter()</code>","text":"<p>Cycle through available status filters and refresh the tree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.action_cycle_filter--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>def action_cycle_filter(self) -&gt; None:\n    \"\"\"\n    Cycle through available status filters and refresh the tree.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    current_idx = self.filters.index(self.current_filter)\n    next_idx = (current_idx + 1) % len(self.filters)\n    self.current_filter = self.filters[next_idx]\n\n    # We need to refresh the tree from local defs\n    if self.defs:\n        self.update_tree(self.host, self.port, self.defs)\n\n    self.app.notify(f\"Filter: {self.current_filter or 'All'}\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.find_and_select","level":3,"title":"<code>find_and_select(query)</code>","text":"<p>Find nodes matching query in the ecFlow definitions and select them.</p> <p>This handles searching through unloaded parts of the tree in a background thread to keep the UI responsive.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.find_and_select--parameters","level":5,"title":"Parameters","text":"<p>query : str     The search query.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.find_and_select--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.find_and_select--notes","level":5,"title":"Notes","text":"<p>This is a background worker.</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>@work(exclusive=True, thread=True)\ndef find_and_select(self, query: str) -&gt; None:\n    \"\"\"\n    Find nodes matching query in the ecFlow definitions and select them.\n\n    This handles searching through unloaded parts of the tree in a\n    background thread to keep the UI responsive.\n\n    Parameters\n    ----------\n    query : str\n        The search query.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This is a background worker.\n    \"\"\"\n    self._find_and_select_logic(query)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.on_tree_node_expanded","level":3,"title":"<code>on_tree_node_expanded(event)</code>","text":"<p>Handle node expansion to load children on demand.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.on_tree_node_expanded--parameters","level":5,"title":"Parameters","text":"<p>event : Tree.NodeExpanded[str]     The expansion event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.on_tree_node_expanded--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>def on_tree_node_expanded(self, event: Tree.NodeExpanded[str]) -&gt; None:\n    \"\"\"\n    Handle node expansion to load children on demand.\n\n    Parameters\n    ----------\n    event : Tree.NodeExpanded[str]\n        The expansion event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    node = event.node\n    self._load_children(node)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.select_by_path","level":3,"title":"<code>select_by_path(path)</code>","text":"<p>Select a node by its absolute ecFlow path, expanding parents as needed.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.select_by_path--parameters","level":5,"title":"Parameters","text":"<p>path : str     The absolute path of the node to select.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.select_by_path--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.select_by_path--notes","level":5,"title":"Notes","text":"<p>This is a background worker to avoid blocking the UI thread when loading many nested nodes synchronously.</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>@work(thread=True)\ndef select_by_path(self, path: str) -&gt; None:\n    \"\"\"\n    Select a node by its absolute ecFlow path, expanding parents as needed.\n\n    Parameters\n    ----------\n    path : str\n        The absolute path of the node to select.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This is a background worker to avoid blocking the UI thread when\n    loading many nested nodes synchronously.\n    \"\"\"\n    self._select_by_path_logic(path)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.update_tree","level":3,"title":"<code>update_tree(client_host, client_port, defs)</code>","text":"<p>Rebuild the tree from ecFlow definitions using lazy loading.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.update_tree--parameters","level":5,"title":"Parameters","text":"<p>client_host : str     The hostname of the ecFlow server. client_port : int     The port of the ecFlow server. defs : ecflow.Defs | None     The ecFlow definitions to display.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.update_tree--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.sidebar.SuiteTree.update_tree--notes","level":5,"title":"Notes","text":"<p>This method is typically called from the main thread after a sync.</p> Source code in <code>src/ectop/widgets/sidebar.py</code> <pre><code>def update_tree(self, client_host: str, client_port: int, defs: Defs | None) -&gt; None:\n    \"\"\"\n    Rebuild the tree from ecFlow definitions using lazy loading.\n\n    Parameters\n    ----------\n    client_host : str\n        The hostname of the ecFlow server.\n    client_port : int\n        The port of the ecFlow server.\n    defs : ecflow.Defs | None\n        The ecFlow definitions to display.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This method is typically called from the main thread after a sync.\n    \"\"\"\n    self.host = client_host\n    self.port = client_port\n    self.defs = defs\n    self._all_paths_cache: list[str] | None = None\n    self.clear()\n    if not defs:\n        self.root.label = \"Server Empty\"\n        return\n\n    filter_str = f\" [Filter: {self.current_filter}]\" if self.current_filter else \"\"\n    self.root.label = f\"{ICON_SERVER} {client_host}:{client_port}{filter_str}\"\n\n    # Start background worker for tree population to avoid blocking UI\n    self._populate_tree_worker()\n\n    # Trigger background cache building for search\n    self._build_all_paths_cache_worker()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar","level":2,"title":"<code>StatusBar</code>","text":"<p>               Bases: <code>Static</code></p> <p>A status bar widget to display server information and health.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/statusbar.py</code> <pre><code>class StatusBar(Static):\n    \"\"\"\n    A status bar widget to display server information and health.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the StatusBar.\n\n        Parameters\n        ----------\n        *args : Any\n            Positional arguments for the Static widget.\n        **kwargs : Any\n            Keyword arguments for the Static widget.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.server_info: str = \"Disconnected\"\n        self.last_sync: str = \"Never\"\n        self.status: str = \"Unknown\"\n        self.server_version: str = \"Unknown\"\n\n    def update_status(self, host: str, port: int, status: str = \"Connected\", version: str = \"Unknown\") -&gt; None:\n        \"\"\"\n        Update the status bar information.\n\n        Parameters\n        ----------\n        host : str\n            The ecFlow server hostname.\n        port : int\n            The ecFlow server port.\n        status : str, optional\n            The server status message, by default \"Connected\".\n        version : str, optional\n            The ecFlow server version, by default \"Unknown\".\n        \"\"\"\n        self.server_info = f\"{host}:{port}\"\n        self.status = str(status)\n        self.server_version = str(version)\n        self.last_sync = datetime.now().strftime(\"%H:%M:%S\")\n        self._refresh_content()\n\n    def _refresh_content(self) -&gt; None:\n        \"\"\"Refresh the rendered content of the status bar.\"\"\"\n        self.refresh()\n\n    def render(self) -&gt; Text:\n        \"\"\"\n        Render the status bar.\n\n        Returns\n        -------\n        Text\n            The rendered status bar content.\n        \"\"\"\n        status_color = \"red\"\n        if self.status == \"RUNNING\":\n            status_color = \"green\"\n        elif self.status == \"HALTED\":\n            status_color = COLOR_STATUS_HALTED\n        elif \"Connected\" in self.status:\n            status_color = \"green\"\n\n        return Text.assemble(\n            (\" Server: \", \"bold\"),\n            (self.server_info, \"cyan\"),\n            (\" (v\", \"bold\"),\n            (self.server_version, \"magenta\"),\n            (\")\", \"bold\"),\n            (\" | Status: \", \"bold\"),\n            (self.status, status_color),\n            (\" | Last Sync: \", \"bold\"),\n            (self.last_sync, \"yellow\"),\n        )\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.__init__","level":3,"title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the StatusBar.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.__init__--parameters","level":5,"title":"Parameters","text":"<p>args : Any     Positional arguments for the Static widget. *kwargs : Any     Keyword arguments for the Static widget.</p> Source code in <code>src/ectop/widgets/statusbar.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the StatusBar.\n\n    Parameters\n    ----------\n    *args : Any\n        Positional arguments for the Static widget.\n    **kwargs : Any\n        Keyword arguments for the Static widget.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.server_info: str = \"Disconnected\"\n    self.last_sync: str = \"Never\"\n    self.status: str = \"Unknown\"\n    self.server_version: str = \"Unknown\"\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.render","level":3,"title":"<code>render()</code>","text":"<p>Render the status bar.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.render--returns","level":5,"title":"Returns","text":"<p>Text     The rendered status bar content.</p> Source code in <code>src/ectop/widgets/statusbar.py</code> <pre><code>def render(self) -&gt; Text:\n    \"\"\"\n    Render the status bar.\n\n    Returns\n    -------\n    Text\n        The rendered status bar content.\n    \"\"\"\n    status_color = \"red\"\n    if self.status == \"RUNNING\":\n        status_color = \"green\"\n    elif self.status == \"HALTED\":\n        status_color = COLOR_STATUS_HALTED\n    elif \"Connected\" in self.status:\n        status_color = \"green\"\n\n    return Text.assemble(\n        (\" Server: \", \"bold\"),\n        (self.server_info, \"cyan\"),\n        (\" (v\", \"bold\"),\n        (self.server_version, \"magenta\"),\n        (\")\", \"bold\"),\n        (\" | Status: \", \"bold\"),\n        (self.status, status_color),\n        (\" | Last Sync: \", \"bold\"),\n        (self.last_sync, \"yellow\"),\n    )\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.update_status","level":3,"title":"<code>update_status(host, port, status='Connected', version='Unknown')</code>","text":"<p>Update the status bar information.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.statusbar.StatusBar.update_status--parameters","level":5,"title":"Parameters","text":"<p>host : str     The ecFlow server hostname. port : int     The ecFlow server port. status : str, optional     The server status message, by default \"Connected\". version : str, optional     The ecFlow server version, by default \"Unknown\".</p> Source code in <code>src/ectop/widgets/statusbar.py</code> <pre><code>def update_status(self, host: str, port: int, status: str = \"Connected\", version: str = \"Unknown\") -&gt; None:\n    \"\"\"\n    Update the status bar information.\n\n    Parameters\n    ----------\n    host : str\n        The ecFlow server hostname.\n    port : int\n        The ecFlow server port.\n    status : str, optional\n        The server status message, by default \"Connected\".\n    version : str, optional\n        The ecFlow server version, by default \"Unknown\".\n    \"\"\"\n    self.server_info = f\"{host}:{port}\"\n    self.status = str(status)\n    self.server_version = str(version)\n    self.last_sync = datetime.now().strftime(\"%H:%M:%S\")\n    self._refresh_content()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#modals","level":2,"title":"Modals","text":"<p>Confirmation modal dialog.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Modal screen for viewing and editing ecFlow variables.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> <p>Modal screen for inspecting why an ecFlow node is not running.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal","level":2,"title":"<code>ConfirmModal</code>","text":"<p>               Bases: <code>ModalScreen[None]</code></p> <p>A modal screen for confirmation actions.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>class ConfirmModal(ModalScreen[None]):\n    \"\"\"\n    A modal screen for confirmation actions.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"close\", \"Cancel\"),\n        Binding(\"y\", \"confirm\", \"Yes\"),\n        Binding(\"n\", \"close\", \"No\"),\n    ]\n\n    def __init__(self, message: str, callback: Callable[[], None]) -&gt; None:\n        \"\"\"\n        Initialize the ConfirmModal.\n\n        Parameters\n        ----------\n        message : str\n            The message to display in the modal.\n        callback : Callable[[], None]\n            The function to call if confirmed.\n        \"\"\"\n        super().__init__()\n        self.message: str = message\n        self.callback: Callable[[], None] = callback\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Compose the modal UI.\n\n        Returns\n        -------\n        ComposeResult\n            The UI components for the modal.\n        \"\"\"\n        with Vertical(id=\"confirm_container\"):\n            yield Static(self.message, id=\"confirm_message\")\n            with Horizontal(id=\"confirm_actions\"):\n                yield Button(\"Yes (y)\", variant=\"success\", id=\"yes_btn\")\n                yield Button(\"No (n)\", variant=\"error\", id=\"no_btn\")\n\n    def action_close(self) -&gt; None:\n        \"\"\"Close the modal without confirming.\"\"\"\n        self.app.pop_screen()\n\n    def action_confirm(self) -&gt; None:\n        \"\"\"Confirm the action and call the callback.\"\"\"\n        self.callback()\n        self.app.pop_screen()\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Handle button press events.\n\n        Parameters\n        ----------\n        event : Button.Pressed\n            The button press event.\n        \"\"\"\n        if event.button.id == \"yes_btn\":\n            self.action_confirm()\n        else:\n            self.action_close()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.__init__","level":3,"title":"<code>__init__(message, callback)</code>","text":"<p>Initialize the ConfirmModal.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.__init__--parameters","level":5,"title":"Parameters","text":"<p>message : str     The message to display in the modal. callback : Callable[[], None]     The function to call if confirmed.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>def __init__(self, message: str, callback: Callable[[], None]) -&gt; None:\n    \"\"\"\n    Initialize the ConfirmModal.\n\n    Parameters\n    ----------\n    message : str\n        The message to display in the modal.\n    callback : Callable[[], None]\n        The function to call if confirmed.\n    \"\"\"\n    super().__init__()\n    self.message: str = message\n    self.callback: Callable[[], None] = callback\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.action_close","level":3,"title":"<code>action_close()</code>","text":"<p>Close the modal without confirming.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>def action_close(self) -&gt; None:\n    \"\"\"Close the modal without confirming.\"\"\"\n    self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.action_confirm","level":3,"title":"<code>action_confirm()</code>","text":"<p>Confirm the action and call the callback.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>def action_confirm(self) -&gt; None:\n    \"\"\"Confirm the action and call the callback.\"\"\"\n    self.callback()\n    self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.compose","level":3,"title":"<code>compose()</code>","text":"<p>Compose the modal UI.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.compose--returns","level":5,"title":"Returns","text":"<p>ComposeResult     The UI components for the modal.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Compose the modal UI.\n\n    Returns\n    -------\n    ComposeResult\n        The UI components for the modal.\n    \"\"\"\n    with Vertical(id=\"confirm_container\"):\n        yield Static(self.message, id=\"confirm_message\")\n        with Horizontal(id=\"confirm_actions\"):\n            yield Button(\"Yes (y)\", variant=\"success\", id=\"yes_btn\")\n            yield Button(\"No (n)\", variant=\"error\", id=\"no_btn\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.on_button_pressed","level":3,"title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button press events.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.confirm.ConfirmModal.on_button_pressed--parameters","level":5,"title":"Parameters","text":"<p>event : Button.Pressed     The button press event.</p> Source code in <code>src/ectop/widgets/modals/confirm.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"\n    Handle button press events.\n\n    Parameters\n    ----------\n    event : Button.Pressed\n        The button press event.\n    \"\"\"\n    if event.button.id == \"yes_btn\":\n        self.action_confirm()\n    else:\n        self.action_close()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker","level":2,"title":"<code>VariableTweaker</code>","text":"<p>               Bases: <code>ModalScreen[None]</code></p> <p>A modal screen for managing ecFlow node variables.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>class VariableTweaker(ModalScreen[None]):\n    \"\"\"\n    A modal screen for managing ecFlow node variables.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"close\", \"Close\"),\n        Binding(\"v\", \"close\", \"Close\"),\n        Binding(\"a\", \"add_variable\", \"Add Variable\"),\n        Binding(\"d\", \"delete_variable\", \"Delete Variable\"),\n    ]\n\n    def __init__(self, node_path: str, client: EcflowClient) -&gt; None:\n        \"\"\"\n        Initialize the VariableTweaker.\n\n        Parameters\n        ----------\n        node_path : str\n            The absolute path to the ecFlow node.\n        client : EcflowClient\n            The ecFlow client instance.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__init__()\n        self.node_path: str = node_path\n        self.client: EcflowClient = client\n        self.selected_var_name: str | None = None\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Compose the modal UI.\n\n        Returns\n        -------\n        ComposeResult\n            The UI components for the modal.\n        \"\"\"\n        with Vertical(id=\"var_container\"):\n            yield Static(f\"Variables for {self.node_path}\", id=\"var_title\")\n            yield DataTable(id=\"var_table\")\n            yield Input(placeholder=\"Enter new value...\", id=\"var_input\")\n            with Horizontal(id=\"var_actions\"):\n                yield Button(\"Close\", variant=\"primary\", id=\"close_btn\")\n\n    def on_mount(self) -&gt; None:\n        \"\"\"\n        Handle the mount event to initialize the table.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        table = self.query_one(\"#var_table\", DataTable)\n        table.add_columns(\"Name\", \"Value\", \"Type\")\n        table.cursor_type = \"row\"\n        self.refresh_vars()\n        self.query_one(\"#var_input\").add_class(\"hidden\")\n\n    def action_close(self) -&gt; None:\n        \"\"\"\n        Close the modal.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.app.pop_screen()\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Handle button press events.\n\n        Parameters\n        ----------\n        event : Button.Pressed\n            The button press event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if event.button.id == \"close_btn\":\n            self.app.pop_screen()\n\n    @work(thread=True)\n    def refresh_vars(self) -&gt; None:\n        \"\"\"\n        Fetch variables from the server and refresh the table in a background worker.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        self._refresh_vars_logic()\n\n    def _refresh_vars_logic(self) -&gt; None:\n        \"\"\"\n        The actual logic for fetching variables and updating the UI.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If server synchronization fails.\n\n        Notes\n        -----\n        This method can be called directly for testing.\n        \"\"\"\n        try:\n            self.client.sync_local()\n            defs = self.client.get_defs()\n            if not defs:\n                return\n            node = defs.find_abs_node(self.node_path)\n\n            if not node:\n                self.app.call_from_thread(self.app.notify, \"Node not found\", severity=\"error\")\n                return\n\n            rows: list[tuple[str, str, str, str]] = []\n            seen_vars: set[str] = set()\n\n            # User variables\n            for var in node.variables:\n                rows.append((var.name(), var.value(), VAR_TYPE_USER, var.name()))\n                seen_vars.add(var.name())\n\n            # Generated variables\n            for var in node.get_generated_variables():\n                rows.append((var.name(), var.value(), VAR_TYPE_GENERATED, var.name()))\n                seen_vars.add(var.name())\n\n            # Inherited variables (climb up the tree)\n            parent = node.get_parent()\n            while parent:\n                for var in parent.variables:\n                    # Only add if not already present (overridden)\n                    if var.name() not in seen_vars:\n                        rows.append(\n                            (\n                                var.name(),\n                                var.value(),\n                                f\"{VAR_TYPE_INHERITED} ({parent.name()})\",\n                                f\"{INHERITED_VAR_PREFIX}{var.name()}\",\n                            )\n                        )\n                        seen_vars.add(var.name())\n                parent = parent.get_parent()\n\n            self.app.call_from_thread(self._update_table, rows)\n\n        except RuntimeError as e:\n            self.app.call_from_thread(self.app.notify, f\"Error fetching variables: {e}\", severity=\"error\")\n        except Exception as e:\n            self.app.call_from_thread(self.app.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def _update_table(self, rows: list[tuple[str, str, str, str]]) -&gt; None:\n        \"\"\"\n        Update the DataTable with new rows.\n\n        Parameters\n        ----------\n        rows : list[tuple[str, str, str, str]]\n            The rows to add to the table.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        table = self.query_one(\"#var_table\", DataTable)\n        table.clear()\n        for row in rows:\n            table.add_row(row[0], row[1], row[2], key=row[3])\n\n    def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:\n        \"\"\"\n        Handle row selection to start editing a variable.\n\n        Parameters\n        ----------\n        event : DataTable.RowSelected\n            The row selection event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        row_key = event.row_key.value\n        if row_key and row_key.startswith(INHERITED_VAR_PREFIX):\n            self.app.notify(\"Cannot edit inherited variables directly. Add it to this node to override.\", severity=\"warning\")\n            return\n\n        self.selected_var_name = row_key\n        input_field = self.query_one(\"#var_input\", Input)\n        input_field.remove_class(\"hidden\")\n        input_field.focus()\n\n    def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n        \"\"\"\n        Handle variable submission (add or update).\n\n        Parameters\n        ----------\n        event : Input.Submitted\n            The input submission event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if event.input.id == \"var_input\":\n            self._submit_variable_worker(event.value)\n\n    @work(thread=True)\n    def _submit_variable_worker(self, value: str) -&gt; None:\n        \"\"\"\n        Worker to submit a new or updated variable in a background thread.\n\n        Parameters\n        ----------\n        value : str\n            The new value or 'name=value' string.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        self._submit_variable_logic(value)\n\n    def _submit_variable_logic(self, value: str) -&gt; None:\n        \"\"\"\n        The actual logic for submitting a variable update or addition.\n\n        Parameters\n        ----------\n        value : str\n            The new value or 'name=value' string.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If the server alteration fails.\n\n        Notes\n        -----\n        This method can be called directly for testing.\n        \"\"\"\n        try:\n            if self.selected_var_name:\n                # Editing existing\n                self.client.alter(self.node_path, \"add_variable\", self.selected_var_name, value)\n                self.app.call_from_thread(self.app.notify, f\"Updated {self.selected_var_name}\")\n            else:\n                # Adding new (expecting name=value)\n                if \"=\" in value:\n                    name, val = value.split(\"=\", 1)\n                    self.client.alter(self.node_path, \"add_variable\", name.strip(), val.strip())\n                    self.app.call_from_thread(self.app.notify, f\"Added {name.strip()}\")\n                else:\n                    self.app.call_from_thread(self.app.notify, \"Use name=value format to add\", severity=\"warning\")\n                    return\n\n            self.app.call_from_thread(self._reset_input)\n            self.refresh_vars()\n        except RuntimeError as e:\n            self.app.call_from_thread(self.app.notify, f\"Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.app.call_from_thread(self.app.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n\n    def _reset_input(self) -&gt; None:\n        \"\"\"\n        Reset the input field state.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        input_field = self.query_one(\"#var_input\", Input)\n        input_field.add_class(\"hidden\")\n        input_field.value = \"\"\n        input_field.placeholder = \"Enter new value...\"\n        self.query_one(\"#var_table\").focus()\n\n    def action_add_variable(self) -&gt; None:\n        \"\"\"\n        Show the input field to add a new variable.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        input_field = self.query_one(\"#var_input\", Input)\n        input_field.placeholder = \"Enter name=value to add\"\n        input_field.remove_class(\"hidden\")\n        input_field.focus()\n        self.selected_var_name = None\n\n    def action_delete_variable(self) -&gt; None:\n        \"\"\"\n        Delete the selected variable from the server.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        table = self.query_one(\"#var_table\", DataTable)\n        row_index = table.cursor_row\n        if row_index is not None:\n            # Get row key from the index\n            row_keys = list(table.rows.keys())\n            row_key = row_keys[row_index].value\n            if row_key:\n                self._delete_variable_worker(row_key)\n\n    @work(thread=True)\n    def _delete_variable_worker(self, row_key: str) -&gt; None:\n        \"\"\"\n        Worker to delete a variable from the server in a background thread.\n\n        Parameters\n        ----------\n        row_key : str\n            The name (or key) of the variable to delete.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        self._delete_variable_logic(row_key)\n\n    def _delete_variable_logic(self, row_key: str) -&gt; None:\n        \"\"\"\n        The actual logic for deleting a variable.\n\n        Parameters\n        ----------\n        row_key : str\n            The name (or key) of the variable to delete.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If the server alteration fails.\n\n        Notes\n        -----\n        This method can be called directly for testing.\n        \"\"\"\n        if row_key.startswith(INHERITED_VAR_PREFIX):\n            self.app.call_from_thread(self.app.notify, \"Cannot delete inherited variables\", severity=\"error\")\n            return\n\n        try:\n            self.client.alter(self.node_path, \"delete_variable\", row_key)\n            self.app.call_from_thread(self.app.notify, f\"Deleted {row_key}\")\n            self.refresh_vars()\n        except RuntimeError as e:\n            self.app.call_from_thread(self.app.notify, f\"Error: {e}\", severity=\"error\")\n        except Exception as e:\n            self.app.call_from_thread(self.app.notify, f\"Unexpected Error: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.__init__","level":3,"title":"<code>__init__(node_path, client)</code>","text":"<p>Initialize the VariableTweaker.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.__init__--parameters","level":5,"title":"Parameters","text":"<p>node_path : str     The absolute path to the ecFlow node. client : EcflowClient     The ecFlow client instance.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.__init__--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def __init__(self, node_path: str, client: EcflowClient) -&gt; None:\n    \"\"\"\n    Initialize the VariableTweaker.\n\n    Parameters\n    ----------\n    node_path : str\n        The absolute path to the ecFlow node.\n    client : EcflowClient\n        The ecFlow client instance.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__()\n    self.node_path: str = node_path\n    self.client: EcflowClient = client\n    self.selected_var_name: str | None = None\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_add_variable","level":3,"title":"<code>action_add_variable()</code>","text":"<p>Show the input field to add a new variable.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_add_variable--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def action_add_variable(self) -&gt; None:\n    \"\"\"\n    Show the input field to add a new variable.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    input_field = self.query_one(\"#var_input\", Input)\n    input_field.placeholder = \"Enter name=value to add\"\n    input_field.remove_class(\"hidden\")\n    input_field.focus()\n    self.selected_var_name = None\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_close","level":3,"title":"<code>action_close()</code>","text":"<p>Close the modal.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_close--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def action_close(self) -&gt; None:\n    \"\"\"\n    Close the modal.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_delete_variable","level":3,"title":"<code>action_delete_variable()</code>","text":"<p>Delete the selected variable from the server.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.action_delete_variable--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def action_delete_variable(self) -&gt; None:\n    \"\"\"\n    Delete the selected variable from the server.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    table = self.query_one(\"#var_table\", DataTable)\n    row_index = table.cursor_row\n    if row_index is not None:\n        # Get row key from the index\n        row_keys = list(table.rows.keys())\n        row_key = row_keys[row_index].value\n        if row_key:\n            self._delete_variable_worker(row_key)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.compose","level":3,"title":"<code>compose()</code>","text":"<p>Compose the modal UI.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.compose--returns","level":5,"title":"Returns","text":"<p>ComposeResult     The UI components for the modal.</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Compose the modal UI.\n\n    Returns\n    -------\n    ComposeResult\n        The UI components for the modal.\n    \"\"\"\n    with Vertical(id=\"var_container\"):\n        yield Static(f\"Variables for {self.node_path}\", id=\"var_title\")\n        yield DataTable(id=\"var_table\")\n        yield Input(placeholder=\"Enter new value...\", id=\"var_input\")\n        with Horizontal(id=\"var_actions\"):\n            yield Button(\"Close\", variant=\"primary\", id=\"close_btn\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_button_pressed","level":3,"title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button press events.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_button_pressed--parameters","level":5,"title":"Parameters","text":"<p>event : Button.Pressed     The button press event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_button_pressed--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"\n    Handle button press events.\n\n    Parameters\n    ----------\n    event : Button.Pressed\n        The button press event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if event.button.id == \"close_btn\":\n        self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_data_table_row_selected","level":3,"title":"<code>on_data_table_row_selected(event)</code>","text":"<p>Handle row selection to start editing a variable.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_data_table_row_selected--parameters","level":5,"title":"Parameters","text":"<p>event : DataTable.RowSelected     The row selection event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_data_table_row_selected--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def on_data_table_row_selected(self, event: DataTable.RowSelected) -&gt; None:\n    \"\"\"\n    Handle row selection to start editing a variable.\n\n    Parameters\n    ----------\n    event : DataTable.RowSelected\n        The row selection event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    row_key = event.row_key.value\n    if row_key and row_key.startswith(INHERITED_VAR_PREFIX):\n        self.app.notify(\"Cannot edit inherited variables directly. Add it to this node to override.\", severity=\"warning\")\n        return\n\n    self.selected_var_name = row_key\n    input_field = self.query_one(\"#var_input\", Input)\n    input_field.remove_class(\"hidden\")\n    input_field.focus()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_input_submitted","level":3,"title":"<code>on_input_submitted(event)</code>","text":"<p>Handle variable submission (add or update).</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_input_submitted--parameters","level":5,"title":"Parameters","text":"<p>event : Input.Submitted     The input submission event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_input_submitted--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"\n    Handle variable submission (add or update).\n\n    Parameters\n    ----------\n    event : Input.Submitted\n        The input submission event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if event.input.id == \"var_input\":\n        self._submit_variable_worker(event.value)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_mount","level":3,"title":"<code>on_mount()</code>","text":"<p>Handle the mount event to initialize the table.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.on_mount--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Handle the mount event to initialize the table.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    table = self.query_one(\"#var_table\", DataTable)\n    table.add_columns(\"Name\", \"Value\", \"Type\")\n    table.cursor_type = \"row\"\n    self.refresh_vars()\n    self.query_one(\"#var_input\").add_class(\"hidden\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.refresh_vars","level":3,"title":"<code>refresh_vars()</code>","text":"<p>Fetch variables from the server and refresh the table in a background worker.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.refresh_vars--returns","level":5,"title":"Returns","text":"<p>None</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.variables.VariableTweaker.refresh_vars--notes","level":5,"title":"Notes","text":"<p>This is a background worker that performs blocking I/O.</p> Source code in <code>src/ectop/widgets/modals/variables.py</code> <pre><code>@work(thread=True)\ndef refresh_vars(self) -&gt; None:\n    \"\"\"\n    Fetch variables from the server and refresh the table in a background worker.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n    This is a background worker that performs blocking I/O.\n    \"\"\"\n    self._refresh_vars_logic()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector","level":2,"title":"<code>WhyInspector</code>","text":"<p>               Bases: <code>ModalScreen[None]</code></p> <p>A modal screen to inspect dependencies and triggers of an ecFlow node.</p> <p>.. note::     If you modify features, API, or usage, you MUST update the documentation immediately.</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>class WhyInspector(ModalScreen[None]):\n    \"\"\"\n    A modal screen to inspect dependencies and triggers of an ecFlow node.\n\n    .. note::\n        If you modify features, API, or usage, you MUST update the documentation immediately.\n    \"\"\"\n\n    BINDINGS = [\n        Binding(\"escape\", \"close\", \"Close\"),\n        Binding(\"w\", \"close\", \"Close\"),\n    ]\n\n    def __init__(self, node_path: str, client: EcflowClient) -&gt; None:\n        \"\"\"\n        Initialize the WhyInspector.\n\n        Parameters\n        ----------\n        node_path : str\n            The absolute path to the ecFlow node.\n        client : EcflowClient\n            The ecFlow client instance.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        super().__init__()\n        self.node_path: str = node_path\n        self.client: EcflowClient = client\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Compose the modal UI.\n\n        Returns\n        -------\n        ComposeResult\n            The UI components for the modal.\n        \"\"\"\n        with Vertical(id=\"why_container\"):\n            yield Static(f\"Why is {self.node_path} not running?\", id=\"why_title\")\n            yield Tree(\"Dependencies\", id=\"dep_tree\")\n            with Horizontal(id=\"why_actions\"):\n                yield Button(\"Close\", variant=\"primary\", id=\"close_btn\")\n\n    def on_mount(self) -&gt; None:\n        \"\"\"\n        Handle the mount event to initialize the dependency tree.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.refresh_deps()\n\n    def action_close(self) -&gt; None:\n        \"\"\"\n        Close the modal.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        self.app.pop_screen()\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Handle button press events.\n\n        Parameters\n        ----------\n        event : Button.Pressed\n            The button press event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        if event.button.id == \"close_btn\":\n            self.app.pop_screen()\n\n    def on_tree_node_selected(self, event: Tree.NodeSelected[str]) -&gt; None:\n        \"\"\"\n        Jump to the selected dependency node in the main tree.\n\n        Parameters\n        ----------\n        event : Tree.NodeSelected[str]\n            The tree node selection event.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        node_path = event.node.data\n        if node_path:\n            from ectop.widgets.sidebar import SuiteTree\n\n            try:\n                tree = self.app.query_one(\"#suite_tree\", SuiteTree)\n                tree.select_by_path(node_path)\n                self.app.notify(f\"Jumped to {node_path}\")\n                self.app.pop_screen()\n            except Exception as e:\n                self.app.notify(f\"Failed to jump: {e}\", severity=\"error\")\n\n    def refresh_deps(self) -&gt; None:\n        \"\"\"\n        Fetch dependencies from the server and rebuild the tree.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        tree = self.query_one(\"#dep_tree\", Tree)\n        self._refresh_deps_worker(tree)\n\n    @work(thread=True)\n    def _refresh_deps_worker(self, tree: Tree) -&gt; None:\n        \"\"\"\n        Worker to fetch dependencies from the server and rebuild the tree in a background thread.\n\n        Parameters\n        ----------\n        tree : Tree\n            The tree widget to refresh.\n\n        Returns\n        -------\n        None\n\n        Notes\n        -----\n        This is a background worker that performs blocking I/O.\n        \"\"\"\n        self._refresh_deps_logic(tree)\n\n    def _refresh_deps_logic(self, tree: Tree) -&gt; None:\n        \"\"\"\n        The actual logic for fetching dependencies and updating the UI tree.\n\n        Parameters\n        ----------\n        tree : Tree\n            The tree widget to refresh.\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        RuntimeError\n            If server synchronization fails.\n\n        Notes\n        -----\n        This method can be called directly for testing.\n        \"\"\"\n        self.app.call_from_thread(tree.clear)\n\n        try:\n            self.client.sync_local()\n            defs = self.client.get_defs()\n            if not defs:\n                self.app.call_from_thread(self._update_tree_root, tree, \"Server Empty\")\n                return\n\n            node = defs.find_abs_node(self.node_path)\n\n            if not node:\n                self.app.call_from_thread(self._update_tree_root, tree, \"Node not found\")\n                return\n\n            # Populate the tree (UI operations must be on main thread)\n            self.app.call_from_thread(self._populate_dep_tree, tree, node, defs)\n\n        except RuntimeError as e:\n            self.app.call_from_thread(self._update_tree_root, tree, f\"Error: {e}\")\n        except Exception as e:\n            self.app.call_from_thread(self._update_tree_root, tree, f\"Unexpected Error: {e}\")\n\n    def _update_tree_root(self, tree: Tree, label: str) -&gt; None:\n        \"\"\"\n        Update the tree root label.\n\n        Parameters\n        ----------\n        tree : Tree\n            The tree widget.\n        label : str\n            The new label for the root.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        tree.root.label = label\n\n    def _populate_dep_tree(self, tree: Tree, node: Node, defs: Defs) -&gt; None:\n        \"\"\"\n        Populate the dependency tree UI.\n\n        Parameters\n        ----------\n        tree : Tree\n            The tree widget to populate.\n        node : Node\n            The ecFlow node.\n        defs : Defs\n            The ecFlow definitions.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        # Server's \"Why\" explanation\n        try:\n            # Standard ecflow node.get_why() might require a client sync\n            # but usually it's available on the node if it was synced.\n            why_str = node.get_why()\n            if why_str:\n                tree.root.add(f\"{ICON_REASON} Reason: [italic]{why_str}[/]\", expand=True)\n        except AttributeError:\n            pass\n\n        # Triggers\n        trigger = node.get_trigger()\n        if trigger:\n            t_node = tree.root.add(\"Triggers\")\n            self._parse_expression(t_node, trigger.get_expression(), defs)\n\n        # Complete\n        complete = node.get_complete()\n        if complete:\n            c_node = tree.root.add(\"Complete Expression\")\n            self._parse_expression(c_node, complete.get_expression(), defs)\n\n        # Limits\n        self._add_limit_deps(tree.root, node)\n\n        # Times, Dates, Crons\n        self._add_time_deps(tree.root, node)\n\n        tree.root.expand_all()\n\n    def _add_limit_deps(self, parent_ui_node: TreeNode[str], node: Node) -&gt; None:\n        \"\"\"\n        Add limit-based dependencies to the UI tree.\n\n        Parameters\n        ----------\n        parent_ui_node : TreeNode[str]\n            The parent node in the Textual tree.\n        node : Node\n            The ecFlow node to inspect.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        inlimits = list(node.inlimits)\n        if inlimits:\n            limit_node = parent_ui_node.add(\"Limits\")\n            for il in inlimits:\n                limit_node.add(f\" Limit: {il.name()} (Path: {il.value()})\")\n\n    def _parse_expression(self, parent_ui_node: TreeNode[str], expr_str: str, defs: Defs) -&gt; bool:\n        \"\"\"\n        Parse an ecFlow expression and add it to the UI tree.\n\n        Parameters\n        ----------\n        parent_ui_node : TreeNode[str]\n            The parent node in the Textual tree.\n        expr_str : str\n            The expression string to parse.\n        defs : Defs\n            The ecFlow definitions for node lookups.\n\n        Returns\n        -------\n        bool\n            True if the expression is currently met.\n        \"\"\"\n        expr_str = expr_str.strip()\n        if not expr_str:\n            return True\n\n        # Remove outer parentheses if they wrap the whole expression\n        while expr_str.startswith(\"(\") and expr_str.endswith(\")\"):\n            depth = 0\n            is_pair = True\n            for i, char in enumerate(expr_str):\n                if char == \"(\":\n                    depth += 1\n                elif char == \")\":\n                    depth -= 1\n                if depth == 0 and i &lt; len(expr_str) - 1:\n                    is_pair = False\n                    break\n            if is_pair:\n                expr_str = expr_str[1:-1].strip()\n            else:\n                break\n\n        # Handle NOT operator\n        if expr_str.startswith(\"!\"):\n            not_node = parent_ui_node.add(\"NOT (Must be false)\", expand=True)\n            inner_met = self._parse_expression(not_node, expr_str[1:].strip(), defs)\n            is_met = not inner_met\n            not_node.label = f\"{ICON_MET if is_met else ICON_NOT_MET} {not_node.label}\"\n            return is_met\n\n        # Find top-level ' or ' or ' and ' (lowest precedence first)\n        for op, label in [(\" or \", EXPR_OR_LABEL), (\" and \", EXPR_AND_LABEL)]:\n            depth = 0\n            for i in range(len(expr_str)):\n                if expr_str[i] == \"(\":\n                    depth += 1\n                elif expr_str[i] == \")\":\n                    depth -= 1\n                elif depth == 0 and expr_str[i : i + len(op)] == op:\n                    op_node = parent_ui_node.add(label, expand=True)\n                    left = expr_str[:i].strip()\n                    right = expr_str[i + len(op) :].strip()\n                    is_met_left = self._parse_expression(op_node, left, defs)\n                    is_met_right = self._parse_expression(op_node, right, defs)\n                    is_met = (is_met_left or is_met_right) if op == \" or \" else (is_met_left and is_met_right)\n                    op_node.label = f\"{ICON_MET if is_met else ICON_NOT_MET} {op_node.label}\"\n                    return is_met\n\n        # Leaf node (actual condition)\n        # Support various comparisons: ==, !=, &lt;, &gt;, &lt;=, &gt;=\n        # Regex supports paths with alphanumeric, underscores, dashes, and dots.\n        # It also handles optional negation prefix if not already caught by the recursion.\n        match = re.search(r\"(!?\\s*)(/[a-zA-Z0-9_\\-\\./]+)(\\s*(==|!=|&lt;=|&gt;=|&lt;|&gt;)\\s*(\\w+))?\", expr_str)\n        if match:\n            negation = match.group(1).strip()\n            path = match.group(2)\n            op = match.group(4) or \"==\"\n            expected_state = match.group(5) or \"complete\"\n            target_node = defs.find_abs_node(path)\n\n            if target_node:\n                actual_state = str(target_node.get_state())\n                # Basic evaluation logic for common states\n                is_met = False\n                if op == \"==\":\n                    is_met = actual_state == expected_state\n                elif op == \"!=\":\n                    is_met = actual_state != expected_state\n                # Other operators are harder to evaluate without state ordering knowledge,\n                # but we show the status anyway.\n\n                if negation == \"!\":\n                    is_met = not is_met\n\n                icon = ICON_MET if is_met else ICON_NOT_MET\n                neg_str = \"! \" if negation == \"!\" else \"\"\n                label = f\"{icon} {neg_str}{path} {op} {actual_state} (Expected: {expected_state})\"\n\n                # Special highlighting for aborted nodes\n                if actual_state == \"aborted\":\n                    label = f\"[b red]{label} (STOPPED HERE)[/]\"\n\n                parent_ui_node.add(label, data=path)\n                return is_met\n            else:\n                parent_ui_node.add(f\"{ICON_UNKNOWN} {path} (Not found)\")\n                return False\n        else:\n            parent_ui_node.add(f\"{ICON_NOTE} {expr_str}\")\n            return True\n\n    def _add_time_deps(self, parent_ui_node: TreeNode[str], node: Node) -&gt; None:\n        \"\"\"\n        Add time-based dependencies to the UI tree.\n\n        Parameters\n        ----------\n        parent_ui_node : TreeNode[str]\n            The parent node in the Textual tree.\n        node : Node\n            The ecFlow node to inspect.\n\n        Returns\n        -------\n        None\n        \"\"\"\n        for t in node.get_times():\n            parent_ui_node.add(f\"{ICON_TIME} Time: {t}\")\n        for d in node.get_dates():\n            parent_ui_node.add(f\"{ICON_DATE} Date: {d}\")\n        for c in node.get_crons():\n            parent_ui_node.add(f\"{ICON_CRON} Cron: {c}\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.__init__","level":3,"title":"<code>__init__(node_path, client)</code>","text":"<p>Initialize the WhyInspector.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.__init__--parameters","level":5,"title":"Parameters","text":"<p>node_path : str     The absolute path to the ecFlow node. client : EcflowClient     The ecFlow client instance.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.__init__--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def __init__(self, node_path: str, client: EcflowClient) -&gt; None:\n    \"\"\"\n    Initialize the WhyInspector.\n\n    Parameters\n    ----------\n    node_path : str\n        The absolute path to the ecFlow node.\n    client : EcflowClient\n        The ecFlow client instance.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    super().__init__()\n    self.node_path: str = node_path\n    self.client: EcflowClient = client\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.action_close","level":3,"title":"<code>action_close()</code>","text":"<p>Close the modal.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.action_close--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def action_close(self) -&gt; None:\n    \"\"\"\n    Close the modal.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.compose","level":3,"title":"<code>compose()</code>","text":"<p>Compose the modal UI.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.compose--returns","level":5,"title":"Returns","text":"<p>ComposeResult     The UI components for the modal.</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Compose the modal UI.\n\n    Returns\n    -------\n    ComposeResult\n        The UI components for the modal.\n    \"\"\"\n    with Vertical(id=\"why_container\"):\n        yield Static(f\"Why is {self.node_path} not running?\", id=\"why_title\")\n        yield Tree(\"Dependencies\", id=\"dep_tree\")\n        with Horizontal(id=\"why_actions\"):\n            yield Button(\"Close\", variant=\"primary\", id=\"close_btn\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_button_pressed","level":3,"title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button press events.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_button_pressed--parameters","level":5,"title":"Parameters","text":"<p>event : Button.Pressed     The button press event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_button_pressed--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"\n    Handle button press events.\n\n    Parameters\n    ----------\n    event : Button.Pressed\n        The button press event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if event.button.id == \"close_btn\":\n        self.app.pop_screen()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_mount","level":3,"title":"<code>on_mount()</code>","text":"<p>Handle the mount event to initialize the dependency tree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_mount--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Handle the mount event to initialize the dependency tree.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.refresh_deps()\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_tree_node_selected","level":3,"title":"<code>on_tree_node_selected(event)</code>","text":"<p>Jump to the selected dependency node in the main tree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_tree_node_selected--parameters","level":5,"title":"Parameters","text":"<p>event : Tree.NodeSelected[str]     The tree node selection event.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.on_tree_node_selected--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def on_tree_node_selected(self, event: Tree.NodeSelected[str]) -&gt; None:\n    \"\"\"\n    Jump to the selected dependency node in the main tree.\n\n    Parameters\n    ----------\n    event : Tree.NodeSelected[str]\n        The tree node selection event.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    node_path = event.node.data\n    if node_path:\n        from ectop.widgets.sidebar import SuiteTree\n\n        try:\n            tree = self.app.query_one(\"#suite_tree\", SuiteTree)\n            tree.select_by_path(node_path)\n            self.app.notify(f\"Jumped to {node_path}\")\n            self.app.pop_screen()\n        except Exception as e:\n            self.app.notify(f\"Failed to jump: {e}\", severity=\"error\")\n</code></pre>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.refresh_deps","level":3,"title":"<code>refresh_deps()</code>","text":"<p>Fetch dependencies from the server and rebuild the tree.</p>","path":["Reference"],"tags":[]},{"location":"reference/#ectop.widgets.modals.why.WhyInspector.refresh_deps--returns","level":5,"title":"Returns","text":"<p>None</p> Source code in <code>src/ectop/widgets/modals/why.py</code> <pre><code>def refresh_deps(self) -&gt; None:\n    \"\"\"\n    Fetch dependencies from the server and rebuild the tree.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    tree = self.query_one(\"#dep_tree\", Tree)\n    self._refresh_deps_worker(tree)\n</code></pre>","path":["Reference"],"tags":[]},{"location":"tutorial/","level":1,"title":"Tutorial: Getting Started with ectop","text":"<p>This tutorial will guide you through using <code>ectop</code> to monitor and manage a sample ecFlow suite.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#prerequisites","level":2,"title":"Prerequisites","text":"<ol> <li>ecFlow Server: Ensure you have an ecFlow server running. You can start one locally with:     <pre><code>export ECF_PORT=3141\nexport ECF_HOME=$HOME/ecflow_home\nmkdir -p $ECF_HOME\necflow_server\n</code></pre></li> <li>ectop: Installed and ready to use.</li> </ol>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#step-1-create-and-load-the-tutorial-suite","level":2,"title":"Step 1: Create and Load the Tutorial Suite","text":"<p>We have provided an example suite in <code>examples/tutorial_suite.py</code>. This suite simulates a simple data processing workflow with dependencies.</p> <ol> <li> <p>Generate the definition file:     <pre><code>python examples/tutorial_suite.py\n</code></pre>     This will create a <code>tutorial.def</code> file.</p> </li> <li> <p>Load the suite into your server:     <pre><code>ecflow_client --port 3141 --load tutorial.def\n</code></pre></p> </li> <li> <p>Begin play:     <pre><code>ecflow_client --port 3141 --begin tutorial\n</code></pre></p> </li> </ol>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#step-2-launch-ectop","level":2,"title":"Step 2: Launch ectop","text":"<p>Now, start <code>ectop</code> to monitor the suite:</p> <pre><code>ectop\n</code></pre> <p>You should see the <code>tutorial</code> suite in the tree on the left.</p> <p></p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#step-3-monitoring-and-interaction","level":2,"title":"Step 3: Monitoring and Interaction","text":"","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#the-status-bar","level":3,"title":"The Status Bar","text":"<p>At the bottom of the screen, you will find the Status Bar. This provides critical information at a glance: - Server: The host and port you are connected to. - Version: The version of the ecFlow server (e.g., <code>v5.11.4</code>). - Status: The scheduling state of the server (e.g., <code>RUNNING</code> or <code>HALTED</code>). - Last Sync: The exact time of the last successful synchronization with the server.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#the-tree-view","level":3,"title":"The Tree View","text":"<p>The left sidebar shows the hierarchy of your suite. You can use the arrow keys to navigate and <code>Enter</code> to expand or collapse nodes. Icons next to node names indicate their current state (e.g.,  for complete,  for active).</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#viewing-files","level":3,"title":"Viewing Files","text":"<p>Select a task (e.g., <code>tutorial/ingest/get_data</code>) and press <code>l</code> to Load. <code>ectop</code> will fetch the script, the generated job, and any available log output, displaying them in the tabs on the right.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#managing-nodes","level":3,"title":"Managing Nodes","text":"<p><code>ectop</code> provides full control over your ecFlow nodes:</p> <ul> <li>Suspend/Resume: Select a node and press <code>s</code> to Suspend () or <code>u</code> to Resume.</li> <li>Kill: If a task is stuck or running too long, press <code>k</code> to Kill it.</li> <li>Force Complete: Press <code>f</code> to manually move a node to the Complete () state.</li> <li>Requeue: Press <code>R</code> (Shift + R) to reset a node and its children, moving them back to the Queued () state.</li> </ul>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#live-log-updates","level":3,"title":"Live Log Updates","text":"<p>If a task is running (Active ), you can toggle live log tailing by pressing <code>t</code>. The <code>Output</code> tab will periodically refresh with new data from the server.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#searching-within-content","level":3,"title":"Searching within Content","text":"<p>When viewing a large log file or complex script, press <code>Ctrl + F</code> to search within the current content tab. This will highlight matches and allow you to find specific strings quickly.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#why-is-it-queued","level":3,"title":"Why is it queued?","text":"<p>If a node is not running when you expect it to, select it and press <code>w</code>. The Why Inspector will show you the triggers or dependencies that are currently blocking it. This view recursively parses trigger expressions, highlighting exactly which parts of the logic are unmet.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#finding-nodes","level":3,"title":"Finding Nodes","text":"<p>In large suites, finding a specific task can be difficult. Press <code>/</code> to open the Search Box. As you type, <code>ectop</code> will perform a live search across all nodes in the suite. Press <code>Enter</code> to jump to and select the next matching node.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#filtering-by-status","level":3,"title":"Filtering by Status","text":"<p>You can filter the tree to show only nodes in a specific state by pressing <code>F</code> (Shift + F). This cycles through filters like: - Aborted: Focus only on failed tasks. - Active: See what is currently running. - Suspended: Find paused parts of the workflow. - All: Clear all filters.</p> <p>The current filter is displayed in the tree root label.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#managing-variables","level":3,"title":"Managing Variables","text":"<p>Press <code>v</code> to open the Variable Tweaker. - User Variables: Defined specifically on this node. - Generated Variables: Automatic ecFlow variables (like <code>ECF_TRYNO</code>). - Inherited Variables: Variables defined on parent families or the suite itself.</p> <p>To override an inherited variable, simply add a new variable with the same name to the current node.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#utility-actions","level":3,"title":"Utility Actions","text":"<ul> <li>Copy Path: Press <code>c</code> to copy the absolute ecFlow path of the selected node to your clipboard.</li> <li>Manual Refresh: While <code>ectop</code> updates automatically, you can force a full sync of the suite tree by pressing <code>r</code>.</li> </ul>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#server-control","level":3,"title":"Server Control","text":"<p>If you have administrative privileges, you can control the server's scheduling state: - Halt Server: Press <code>H</code> (Shift + H) to stop the server from scheduling any new tasks. The status bar will show <code>HALTED</code>. - Start Server: Press <code>S</code> (Shift + S) to resume scheduling. The status bar will show <code>RUNNING</code>.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#the-command-palette","level":3,"title":"The Command Palette","text":"<p>If you forget a keybinding, press <code>p</code> to open the Command Palette. This searchable interface allows you to execute any action by name (e.g., type \"halt\" to find the \"Halt Server\" command).</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#quitting","level":3,"title":"Quitting","text":"<p>When you are finished, press <code>q</code> to safely exit <code>ectop</code>.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#step-4-editing-scripts-on-the-fly","level":2,"title":"Step 4: Editing Scripts on the Fly","text":"<p>One of <code>ectop</code>'s most powerful features is the ability to edit scripts directly.</p> <ol> <li>Select a task.</li> <li>Press <code>e</code>.</li> <li>Your default editor (defined by <code>$EDITOR</code>) will open with the script content.</li> <li>Make a change and save.</li> <li><code>ectop</code> will prompt you if you want to update the script on the server and optionally Requeue the task to run the new version.</li> </ol>","path":["Tutorial: Getting Started with ectop"],"tags":[]},{"location":"tutorial/#next-steps","level":2,"title":"Next Steps","text":"<p>Explore the Architecture page to learn how <code>ectop</code> works under the hood, or check the Reference for a full list of keybindings.</p>","path":["Tutorial: Getting Started with ectop"],"tags":[]}]}